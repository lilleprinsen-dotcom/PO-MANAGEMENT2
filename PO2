namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() ) {
	return;
}

if ( ! defined( __NAMESPACE__ . '\VERSION' ) ) {
	define( __NAMESPACE__ . '\VERSION', '0.1.0-b1' );
}
if ( ! defined( __NAMESPACE__ . '\OPTION_KEY' ) ) {
	define( __NAMESPACE__ . '\OPTION_KEY', 'lpr_allocator_settings' );
}
if ( ! defined( __NAMESPACE__ . '\DB_VERSION_OPTION' ) ) {
	define( __NAMESPACE__ . '\DB_VERSION_OPTION', 'lpr_allocator_db_version' );
}

/**
 * Meta key constants (guarded).
 */
if ( ! defined( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA' ) ) {
	define( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA', '_lpr_line_eta' );
}
if ( ! defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ) {
	define( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS', 'lpr_allocations' );
}
if ( ! defined( __NAMESPACE__ . '\PRODUCT_META_UNALLOCATED_POOL' ) ) {
	define( __NAMESPACE__ . '\PRODUCT_META_UNALLOCATED_POOL', '_lpr_unallocated_pool' );
}
if ( ! defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_QTY' ) ) {
	define( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_QTY', '_lpr_next_extra_qty' );
}
if ( ! defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_ETA' ) ) {
	define( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_ETA', '_lpr_next_extra_eta' );
}

if ( ! class_exists( __NAMESPACE__ . '\Settings' ) ) {
	/**
	 * Settings storage & helpers.
	 */
	class Settings {

		/**
		 * Default settings.
		 *
		 * @return array
		 */
		public static function defaults(): array {
			return array(
				'order_statuses'        => array( 'processing', 'on-hold' ),
				'inform_customer_eta'   => false,
				'frontend_extra_pool'   => false,
				'brand_logo_url'        => '',
				'brand_primary_color'   => '#1a1a1a',
				'brand_support_email'   => '',
				'brand_support_phone'   => '',
				'email_footer_text_no'  => '',
			);
		}

		/**
		 * Option key.
		 */
		public static function key(): string {
			return OPTION_KEY;
		}

		/**
		 * Get merged settings with defaults applied.
		 */
		public static function get(): array {
			$stored = get_option( self::key(), array() );
			if ( ! is_array( $stored ) ) {
				$stored = array();
			}
			return array_replace( self::defaults(), $stored );
		}

		/**
		 * Update settings. Ensures autoload = no on first write.
		 *
		 * @param array $raw
		 * @return bool
		 */
		public static function update( array $raw ): bool {
			$san = self::sanitize( $raw );

			$exists = get_option( self::key(), null );
			if ( null === $exists ) {
				return add_option( self::key(), $san, '', 'no' );
			}
			return update_option( self::key(), $san, false );
		}

		/**
		 * Sanitize settings.
		 *
		 * @param array $raw
		 * @return array
		 */
		public static function sanitize( array $raw ): array {
			$defaults = self::defaults();

			// Order statuses: store as bare slugs (e.g., 'processing').
			$statuses = array();
			if ( ! empty( $raw['order_statuses'] ) && is_array( $raw['order_statuses'] ) ) {
				foreach ( $raw['order_statuses'] as $st ) {
					$st          = sanitize_key( $st );
					$st          = preg_replace( '/^wc-/', '', $st );
					$statuses[]  = $st;
				}
				$statuses = array_values( array_unique( $statuses ) );
			} else {
				$statuses = $defaults['order_statuses'];
			}

			$inform = ! empty( $raw['inform_customer_eta'] );
			$front  = ! empty( $raw['frontend_extra_pool'] );

			$logo   = isset( $raw['brand_logo_url'] ) ? esc_url_raw( $raw['brand_logo_url'] ) : '';
			$color  = isset( $raw['brand_primary_color'] ) ? sanitize_hex_color( $raw['brand_primary_color'] ) : '';
			if ( empty( $color ) ) {
				$color = $defaults['brand_primary_color'];
			}

			$email  = isset( $raw['brand_support_email'] ) ? sanitize_email( $raw['brand_support_email'] ) : '';
			$phone  = isset( $raw['brand_support_phone'] ) ? sanitize_text_field( $raw['brand_support_phone'] ) : '';
			$footer = isset( $raw['email_footer_text_no'] ) ? wp_kses_post( $raw['email_footer_text_no'] ) : '';

			return array(
				'order_statuses'        => $statuses,
				'inform_customer_eta'   => (bool) $inform,
				'frontend_extra_pool'   => (bool) $front,
				'brand_logo_url'        => $logo,
				'brand_primary_color'   => $color,
				'brand_support_email'   => $email,
				'brand_support_phone'   => $phone,
				'email_footer_text_no'  => $footer,
			);
		}
	}
}

if ( ! class_exists( __NAMESPACE__ . '\Installer' ) ) {
	/**
	 * Versioned installer (admin_init). Prepares options and version markers.
	 */
	class Installer {
		public static function init(): void {
			add_action( 'admin_init', array( __CLASS__, 'maybe_install' ) );
		}

		public static function maybe_install(): void {
			// Ensure settings option exists with autoload=no.
			$existing = get_option( Settings::key(), null );
			if ( null === $existing ) {
				add_option( Settings::key(), Settings::defaults(), '', 'no' );
			}

			// Ensure a DB version flag exists (no schema work in Batch 1).
			if ( null === get_option( DB_VERSION_OPTION, null ) ) {
				add_option( DB_VERSION_OPTION, '0', '', 'no' );
			}
		}
	}
	Installer::init();
}

if ( ! class_exists( __NAMESPACE__ . '\Admin_Settings_Tab' ) ) {
	/**
	 * WooCommerce -> Settings -> Backorders tab.
	 */
	class Admin_Settings_Tab {

		const TAB_ID = 'lpr_backorders';

		public static function init(): void {
			add_filter( 'woocommerce_settings_tabs_array', array( __CLASS__, 'register_tab' ), 50 );
			add_action( 'woocommerce_settings_tabs_' . self::TAB_ID, array( __CLASS__, 'render' ) );
			add_action( 'woocommerce_update_options_' . self::TAB_ID, array( __CLASS__, 'save' ) );
			add_action( 'woocommerce_settings_save_' . self::TAB_ID, array( __CLASS__, 'save' ) );
		}

		/**
		 * Add custom tab.
		 */
		public static function register_tab( array $tabs ): array {
			if ( current_user_can( 'manage_woocommerce' ) ) {
				$tabs[ self::TAB_ID ] = __( 'Backorders', 'lpr-backorder-allocator' );
			}
			return $tabs;
		}

		/**
		 * Build fields array for WC settings renderer.
		 */
		protected static function get_fields( array $settings ): array {
			// Build order status options with bare keys (strip 'wc-').
			$wc_statuses = function_exists( 'wc_get_order_statuses' ) ? wc_get_order_statuses() : array();
			$status_opts = array();
			foreach ( $wc_statuses as $key => $label ) {
				$bare               = preg_replace( '/^wc-/', '', $key );
				$status_opts[ $bare ] = $label;
			}

			return array(
				array(
					'title' => __( 'Backorder Allocator Settings', 'lpr-backorder-allocator' ),
					'type'  => 'title',
					'desc'  => __( 'Configure admin-only allocator behavior and customer-facing communication toggles. Allocation never adjusts stock.', 'lpr-backorder-allocator' ),
					'id'    => 'lpr_allocator_section_main',
				),

				array(
					'title'    => __( 'Order statuses to include', 'lpr-backorder-allocator' ),
					'desc'     => __( 'Orders in these statuses are considered for allocation and reports.', 'lpr-backorder-allocator' ),
					'id'       => 'lpr_allocator_order_statuses',
					'type'     => 'multiselect',
					'class'    => 'wc-enhanced-select',
					'options'  => $status_opts,
					'default'  => Settings::defaults()['order_statuses'],
				),

				array(
					'title'   => __( 'Inform customer of updated ETA', 'lpr-backorder-allocator' ),
					'desc'    => __( 'Send branded email when an order’s ETA changes.', 'lpr-backorder-allocator' ),
					'id'      => 'lpr_allocator_inform_customer_eta',
					'type'    => 'checkbox',
					'default' => 'no',
				),

				array(
					'title'   => __( 'Show available PO stock on frontend', 'lpr-backorder-allocator' ),
					'desc'    => __( 'Writes precomputed product meta only; no frontend logic runs.', 'lpr-backorder-allocator' ),
					'id'      => 'lpr_allocator_frontend_extra_pool',
					'type'    => 'checkbox',
					'default' => 'no',
				),

				array(
					'type'  => 'sectionend',
					'id'    => 'lpr_allocator_section_main',
				),

				array(
					'title' => __( 'Branding', 'lpr-backorder-allocator' ),
					'type'  => 'title',
					'desc'  => __( 'Used for branded emails and admin displays.', 'lpr-backorder-allocator' ),
					'id'    => 'lpr_allocator_section_brand',
				),

				array(
					'title'       => __( 'Brand logo URL', 'lpr-backorder-allocator' ),
					'desc'        => __( 'Absolute URL to a logo image.', 'lpr-backorder-allocator' ),
					'id'          => 'lpr_allocator_brand_logo_url',
					'type'        => 'text',
					'css'         => 'min-width: 400px;',
					'placeholder' => 'https://example.com/logo.png',
					'default'     => '',
				),

				array(
					'title'       => __( 'Primary color', 'lpr-backorder-allocator' ),
					'desc'        => __( 'Hex color used in branded emails.', 'lpr-backorder-allocator' ),
					'id'          => 'lpr_allocator_brand_primary_color',
					'type'        => 'text',
					'css'         => 'width: 120px;',
					'placeholder' => '#1a1a1a',
					'default'     => '#1a1a1a',
				),

				array(
					'title'       => __( 'Support email', 'lpr-backorder-allocator' ),
					'id'          => 'lpr_allocator_brand_support_email',
					'type'        => 'email',
					'placeholder' => 'support@example.com',
					'default'     => '',
				),

				array(
					"title"       => __( 'Support phone', 'lpr-backorder-allocator' ),
					"id"          => 'lpr_allocator_brand_support_phone',
					"type"        => 'text',
					"placeholder" => '+46 70 123 45 67',
					"default"     => '',
				),

				array(
					'title'       => __( 'Email footer text', 'lpr-backorder-allocator' ),
					'id'          => 'lpr_allocator_email_footer_text_no',
					'type'        => 'textarea',
					'css'         => 'min-width: 400px; height: 100px;',
					'placeholder' => __( 'Thank you for your order. Contact us if you have any questions.', 'lpr-backorder-allocator' ),
					'default'     => '',
				),

				array(
					'type'  => 'sectionend',
					'id'    => 'lpr_allocator_section_brand',
				),
			);
		}

		/**
		 * Provide field values to WC renderer from our single option via pre_option_*.
		 */
		protected static function prime_field_values( array $settings ): void {
			$map = array(
				'lpr_allocator_order_statuses'       => (array) $settings['order_statuses'],
				'lpr_allocator_inform_customer_eta'  => $settings['inform_customer_eta'] ? 'yes' : 'no',
				'lpr_allocator_frontend_extra_pool'  => $settings['frontend_extra_pool'] ? 'yes' : 'no',
				'lpr_allocator_brand_logo_url'       => (string) $settings['brand_logo_url'],
				'lpr_allocator_brand_primary_color'  => (string) $settings['brand_primary_color'],
				'lpr_allocator_brand_support_email'  => (string) $settings['brand_support_email'],
				'lpr_allocator_brand_support_phone'  => (string) $settings['brand_support_phone'],
				'lpr_allocator_email_footer_text_no' => (string) $settings['email_footer_text_no'],
			);

			foreach ( $map as $opt => $val ) {
				add_filter(
					'pre_option_' . $opt,
					static function () use ( $val ) {
						return $val;
					}
				);
			}
		}

		/**
		 * Render settings tab.
		 */
		public static function render(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			if ( ! function_exists( 'woocommerce_admin_fields' ) ) {
				return;
			}
			$settings = Settings::get();
			self::prime_field_values( $settings );

			$fields = self::get_fields( $settings );
			woocommerce_admin_fields( $fields );
		}

		/**
		 * Save handler: collect POST, sanitize, and persist in a single option (autoload=no).
		 */
		public static function save(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			if ( function_exists( 'check_admin_referer' ) ) {
				// WooCommerce settings form nonce.
				check_admin_referer( 'woocommerce-settings' );
			}

			$posted_statuses = isset( $_POST['lpr_allocator_order_statuses'] ) ? (array) wp_unslash( $_POST['lpr_allocator_order_statuses'] ) : array();
			$raw = array(
				'order_statuses'        => $posted_statuses,
				'inform_customer_eta'   => ! empty( $_POST['lpr_allocator_inform_customer_eta'] ),
				'frontend_extra_pool'   => ! empty( $_POST['lpr_allocator_frontend_extra_pool'] ),
				'brand_logo_url'        => isset( $_POST['lpr_allocator_brand_logo_url'] ) ? (string) wp_unslash( $_POST['lpr_allocator_brand_logo_url'] ) : '',
				'brand_primary_color'   => isset( $_POST['lpr_allocator_brand_primary_color'] ) ? (string) wp_unslash( $_POST['lpr_allocator_brand_primary_color'] ) : '',
				'brand_support_email'   => isset( $_POST['lpr_allocator_brand_support_email'] ) ? (string) wp_unslash( $_POST['lpr_allocator_brand_support_email'] ) : '',
				'brand_support_phone'   => isset( $_POST['lpr_allocator_brand_support_phone'] ) ? (string) wp_unslash( $_POST['lpr_allocator_brand_support_phone'] ) : '',
				'email_footer_text_no'  => isset( $_POST['lpr_allocator_email_footer_text_no'] ) ? (string) wp_unslash( $_POST['lpr_allocator_email_footer_text_no'] ) : '',
			);

			Settings::update( $raw );

			if ( class_exists( '\WC_Admin_Settings' ) ) {
				\WC_Admin_Settings::add_message( __( 'Backorder Allocator settings saved.', 'lpr-backorder-allocator' ) );
			}
		}
	}
	Admin_Settings_Tab::init();
}

/* SELF-CHECK:
- Added namespaced constants for all required meta keys; guarded with defined().
- Implemented Settings class with option key `lpr_allocator_settings`, defaults (order_statuses ['processing','on-hold'], inform_customer_eta=false, frontend_extra_pool=false, branding fields incl. brand_primary_color '#1a1a1a', email_footer_text_no), getter merges defaults, update() enforces autoload=no on first write.
- Created Installer (admin_init) to seed options and DB version flag; no frontend hooks.
- Registered WooCommerce Settings tab "Backorders" (admin-only). Rendering via woocommerce_admin_fields; values sourced from our single option using pre_option_* filters. Save handler compiles/sanitizes into single option; no stock writes; no wildcard meta queries.
- All declarations are guarded; HPOS/CRUD safe; no frontend impact due to early admin/cron bail.
*/
namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() ) {
	return;
}

/**
 * Constants for Supplier PO CPT and meta keys (guarded).
 */
if ( ! defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ) {
	define( __NAMESPACE__ . '\CPT_SUPPLIER_PO', 'supplier_po' );
}
if ( ! defined( __NAMESPACE__ . '\PO_META_SUPPLIER_NAME' ) ) {
	define( __NAMESPACE__ . '\PO_META_SUPPLIER_NAME', '_lpr_supplier_name' );
}
if ( ! defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ) {
	define( __NAMESPACE__ . '\PO_META_PO_NUMBER', '_lpr_po_number' );
}
if ( ! defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ) {
	define( __NAMESPACE__ . '\PO_META_ETA_DATE', '_lpr_eta_date' ); // Y-m-d
}
if ( ! defined( __NAMESPACE__ . '\PO_META_LINES' ) ) {
	define( __NAMESPACE__ . '\PO_META_LINES', '_lpr_po_lines' );
}
if ( ! defined( __NAMESPACE__ . '\PO_STATUS_OPEN' ) ) {
	define( __NAMESPACE__ . '\PO_STATUS_OPEN', 'open' );
}
if ( ! defined( __NAMESPACE__ . '\PO_STATUS_PARTIAL' ) ) {
	define( __NAMESPACE__ . '\PO_STATUS_PARTIAL', 'partial' );
}
if ( ! defined( __NAMESPACE__ . '\PO_STATUS_CLOSED' ) ) {
	define( __NAMESPACE__ . '\PO_STATUS_CLOSED', 'closed' );
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_sanitize_ymd' ) ) {
	/**
	 * Sanitize a date string to Y-m-d or empty.
	 *
	 * @param string $val
	 * @return string
	 */
	function lpr_allocator_sanitize_ymd( $val ): string {
		$val = trim( (string) $val );
		if ( '' === $val ) {
			return '';
		}
		// Accepts Y-m-d only.
		$d = \DateTime::createFromFormat( 'Y-m-d', $val );
		if ( $d && $d->format( 'Y-m-d' ) === $val ) {
			return $val;
		}
		return '';
	}
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_product_exists' ) ) {
	/**
	 * Validate a product or variation ID via Woo CRUD (HPOS-safe).
	 *
	 * @param int $id
	 * @return bool
	 */
	function lpr_allocator_product_exists( int $id ): bool {
		if ( $id <= 0 ) {
			return false;
		}
		if ( ! function_exists( 'wc_get_product' ) ) {
			return false;
		}
		$product = wc_get_product( $id );
		return $product instanceof \WC_Product;
	}
}

if ( ! class_exists( __NAMESPACE__ . '\Supplier_PO_CPT' ) ) {
	/**
	 * Registers Supplier PO CPT, custom statuses, admin columns, and metaboxes.
	 */
	class Supplier_PO_CPT {

		/**
		 * Prevent recursive save when updating status.
		 *
		 * @var bool
		 */
		protected static $saving = false;

		public static function init(): void {
			add_action( 'init', array( __CLASS__, 'register_statuses' ) );
			add_action( 'init', array( __CLASS__, 'register_cpt' ) );

			add_action( 'add_meta_boxes', array( __CLASS__, 'add_meta_boxes' ) );
			add_action( 'save_post', array( __CLASS__, 'save_post' ), 10, 2 );

			add_filter( 'manage_edit-' . CPT_SUPPLIER_PO . '_columns', array( __CLASS__, 'columns' ) );
			add_action( 'manage_' . CPT_SUPPLIER_PO . '_posts_custom_column', array( __CLASS__, 'column_content' ), 10, 2 );

			add_filter( 'display_post_states', array( __CLASS__, 'display_states' ), 10, 2 );
		}

		public static function register_statuses(): void {
			$statuses = array(
				PO_STATUS_OPEN    => __( 'Open', 'lpr-backorder-allocator' ),
				PO_STATUS_PARTIAL => __( 'Partial', 'lpr-backorder-allocator' ),
				PO_STATUS_CLOSED  => __( 'Closed', 'lpr-backorder-allocator' ),
			);

			foreach ( $statuses as $key => $label ) {
				if ( ! get_post_status_object( $key ) ) {
					register_post_status(
						$key,
						array(
							'label'                     => $label,
							'public'                    => false,
							'internal'                  => false,
							'exclude_from_search'       => true,
							'show_in_admin_all_list'    => true,
							'show_in_admin_status_list' => true,
							'label_count'               => _n_noop( "$label <span class=\"count\">(%s)</span>", "$label <span class=\"count\">(%s)</span>", 'lpr-backorder-allocator' ),
						)
					);
				}
			}
		}

		public static function register_cpt(): void {
			$labels = array(
				'name'               => __( 'Supplier POs', 'lpr-backorder-allocator' ),
				'singular_name'      => __( 'Supplier PO', 'lpr-backorder-allocator' ),
				'add_new'            => __( 'Add New', 'lpr-backorder-allocator' ),
				'add_new_item'       => __( 'Add New Supplier PO', 'lpr-backorder-allocator' ),
				'edit_item'          => __( 'Edit Supplier PO', 'lpr-backorder-allocator' ),
				'new_item'           => __( 'New Supplier PO', 'lpr-backorder-allocator' ),
				'all_items'          => __( 'Supplier POs', 'lpr-backorder-allocator' ),
				'view_item'          => __( 'View Supplier PO', 'lpr-backorder-allocator' ),
				'search_items'       => __( 'Search Supplier POs', 'lpr-backorder-allocator' ),
				'not_found'          => __( 'No Supplier POs found', 'lpr-backorder-allocator' ),
				'not_found_in_trash' => __( 'No Supplier POs found in Trash', 'lpr-backorder-allocator' ),
				'menu_name'          => __( 'Supplier POs', 'lpr-backorder-allocator' ),
			);

			$caps = array_fill_keys(
				array(
					'edit_post',
					'read_post',
					'delete_post',
					'edit_posts',
					'edit_others_posts',
					'publish_posts',
					'read_private_posts',
					'read',
					'delete_posts',
					'delete_private_posts',
					'delete_published_posts',
					'delete_others_posts',
					'edit_private_posts',
					'edit_published_posts',
					'create_posts',
				),
				'manage_woocommerce'
			);

			register_post_type(
				CPT_SUPPLIER_PO,
				array(
					'labels'              => $labels,
					'public'              => false,
					'show_ui'             => true,
					'show_in_menu'        => 'woocommerce',
					'show_in_admin_bar'   => false,
					'show_in_rest'        => false,
					'has_archive'         => false,
					'exclude_from_search' => true,
					'rewrite'             => false,
					'map_meta_cap'        => false,
					'capabilities'        => $caps,
					'supports'            => array( 'title' ),
					'menu_icon'           => 'dashicons-clipboard',
				)
			);
		}

		public static function add_meta_boxes(): void {
			add_meta_box(
				'lpr_po_header',
				__( 'PO Header', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_header_metabox' ),
				CPT_SUPPLIER_PO,
				'normal',
				'high'
			);

			add_meta_box(
				'lpr_po_lines',
				__( 'PO Lines', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_lines_metabox' ),
				CPT_SUPPLIER_PO,
				'normal',
				'default'
			);
		}

		public static function render_header_metabox( \WP_Post $post ): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			wp_nonce_field( 'lpr_po_header_action', 'lpr_po_header_nonce' );

			$supplier  = get_post_meta( $post->ID, PO_META_SUPPLIER_NAME, true );
			$po_number = get_post_meta( $post->ID, PO_META_PO_NUMBER, true );
			$eta       = get_post_meta( $post->ID, PO_META_ETA_DATE, true );
			$status    = in_array( $post->post_status, array( PO_STATUS_OPEN, PO_STATUS_PARTIAL, PO_STATUS_CLOSED ), true ) ? $post->post_status : PO_STATUS_OPEN;

			?>
			<style>
				#lpr_po_header .lpr-grid { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
				#lpr_po_header .lpr-grid .field { display:flex; flex-direction:column; }
				#lpr_po_header input[type="text"], #lpr_po_header input[type="date"], #lpr_po_header select { max-width: 420px; }
			</style>
			<div class="lpr-grid">
				<div class="field">
					<label for="lpr_supplier_name"><strong><?php echo esc_html__( 'Supplier Name', 'lpr-backorder-allocator' ); ?></strong></label>
					<input type="text" id="lpr_supplier_name" name="lpr_supplier_name" value="<?php echo esc_attr( (string) $supplier ); ?>" />
				</div>
				<div class="field">
					<label for="lpr_po_number"><strong><?php echo esc_html__( 'PO Number', 'lpr-backorder-allocator' ); ?></strong></label>
					<input type="text" id="lpr_po_number" name="lpr_po_number" value="<?php echo esc_attr( (string) $po_number ); ?>" />
				</div>
				<div class="field">
					<label for="lpr_eta_date"><strong><?php echo esc_html__( 'Default ETA (Y-m-d)', 'lpr-backorder-allocator' ); ?></strong></label>
					<input type="date" id="lpr_eta_date" name="lpr_eta_date" value="<?php echo esc_attr( (string) $eta ); ?>" pattern="\d{4}-\d{2}-\d{2}" />
				</div>
				<div class="field">
					<label for="lpr_po_status"><strong><?php echo esc_html__( 'PO Status', 'lpr-backorder-allocator' ); ?></strong></label>
					<select id="lpr_po_status" name="lpr_po_status">
						<?php
						$opts = array(
							PO_STATUS_OPEN    => __( 'Open', 'lpr-backorder-allocator' ),
							PO_STATUS_PARTIAL => __( 'Partial', 'lpr-backorder-allocator' ),
							PO_STATUS_CLOSED  => __( 'Closed', 'lpr-backorder-allocator' ),
						);
						foreach ( $opts as $val => $label ) {
							printf(
								'<option value="%s"%s>%s</option>',
								esc_attr( $val ),
								selected( $status, $val, false ),
								esc_html( $label )
							);
						}
						?>
					</select>
				</div>
			</div>
			<?php
		}

		public static function render_lines_metabox( \WP_Post $post ): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			wp_nonce_field( 'lpr_po_lines_action', 'lpr_po_lines_nonce' );
			$lines = get_post_meta( $post->ID, PO_META_LINES, true );
			if ( ! is_array( $lines ) ) {
				$lines = array();
			}
			?>
			<style>
				#lpr_po_lines table { width: 100%; border-collapse: collapse; }
				#lpr_po_lines th, #lpr_po_lines td { border-bottom: 1px solid #ddd; padding: 6px; text-align:left; }
				#lpr_po_lines .actions { text-align: right; margin-top: 8px; }
				#lpr_po_lines input[type="number"] { width: 100px; }
				#lpr_po_lines input[type="text"] { width: 160px; }
			</style>
			<table class="widefat striped" id="lpr-po-lines-table">
				<thead>
					<tr>
						<th><?php echo esc_html__( 'Product ID', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Variation ID', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Qty Ordered', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Qty Allocated', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'ETA Override (Y-m-d)', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Qty Received', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Remove', 'lpr-backorder-allocator' ); ?></th>
					</tr>
				</thead>
				<tbody>
					<?php
					$idx = 0;
					foreach ( $lines as $line ) :
						$product_id   = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
						$variation_id = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
						$qty_ordered  = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
						$qty_alloc    = isset( $line['qty_allocated'] ) ? max( 0, (int) $line['qty_allocated'] ) : 0;
						$eta_override = isset( $line['eta_override'] ) ? (string) $line['eta_override'] : '';
						$qty_recv     = isset( $line['qty_received'] ) ? max( 0, (int) $line['qty_received'] ) : 0;
						?>
						<tr>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][product_id]" value="<?php echo esc_attr( $product_id ); ?>" /></td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][variation_id]" value="<?php echo esc_attr( $variation_id ); ?>" /></td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][qty_ordered]" value="<?php echo esc_attr( $qty_ordered ); ?>" /></td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][qty_allocated]" value="<?php echo esc_attr( $qty_alloc ); ?>" /></td>
							<td><input type="text" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][eta_override]" value="<?php echo esc_attr( $eta_override ); ?>" placeholder="YYYY-MM-DD" /></td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][qty_received]" value="<?php echo esc_attr( $qty_recv ); ?>" /></td>
							<td><button type="button" class="button link-delete lpr-remove-line"><?php echo esc_html__( 'Remove', 'lpr-backorder-allocator' ); ?></button></td>
						</tr>
						<?php
						$idx++;
					endforeach;
					?>
				</tbody>
			</table>
			<div class="actions">
				<button type="button" class="button button-secondary" id="lpr-add-line"><?php echo esc_html__( 'Add Line', 'lpr-backorder-allocator' ); ?></button>
			</div>
			<script>
				(function(){
					const table = document.getElementById('lpr-po-lines-table').getElementsByTagName('tbody')[0];
					const addBtn = document.getElementById('lpr-add-line');
					function nextIndex(){
						let max = -1;
						table.querySelectorAll('tr').forEach(function(tr){
							const m = tr.querySelector('input[name^="lpr_po_lines["]')?.name.match(/^lpr_po_lines\[(\d+)\]/);
							if(m){ max = Math.max(max, parseInt(m[1], 10)); }
						});
						return max + 1;
					}
					function onRemoveClick(e){
						if(e.target && e.target.classList.contains('lpr-remove-line')){
							e.preventDefault();
							const tr = e.target.closest('tr');
							if(tr){ tr.remove(); }
						}
					}
					addBtn.addEventListener('click', function(e){
						e.preventDefault();
						const i = nextIndex();
						const tr = document.createElement('tr');
						tr.innerHTML =
							'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][product_id]" value="" /></td>'+
							'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][variation_id]" value="" /></td>'+
							'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][qty_ordered]" value="0" /></td>'+
							'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][qty_allocated]" value="0" /></td>'+
							'<td><input type="text" name="lpr_po_lines['+i+'][eta_override]" value="" placeholder="YYYY-MM-DD" /></td>'+
							'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][qty_received]" value="0" /></td>'+
							'<td><button type="button" class="button link-delete lpr-remove-line"><?php echo esc_js( __( 'Remove', 'lpr-backorder-allocator' ) ); ?></button></td>';
						table.appendChild(tr);
					});
					table.addEventListener('click', onRemoveClick);
				})();
			</script>
			<p class="description">
				<?php echo esc_html__( 'Provide either Product ID or Variation ID for each line. Received defaults to 0. Allocation is a ledger only; no stock writes.', 'lpr-backorder-allocator' ); ?>
			</p>
			<?php
		}

		public static function save_post( int $post_id, \WP_Post $post ): void {
			if ( self::$saving ) {
				return;
			}
			if ( CPT_SUPPLIER_PO !== $post->post_type ) {
				return;
			}
			// Bail on autosave/revision.
			if ( defined( 'DOING_AUTOSAVE' ) && DOING_AUTOSAVE ) {
				return;
			}
			if ( wp_is_post_revision( $post_id ) ) {
				return;
			}
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}

			// Header save.
			if ( isset( $_POST['lpr_po_header_nonce'] ) && wp_verify_nonce( sanitize_text_field( wp_unslash( $_POST['lpr_po_header_nonce'] ) ), 'lpr_po_header_action' ) ) {
				$supplier  = isset( $_POST['lpr_supplier_name'] ) ? sanitize_text_field( wp_unslash( $_POST['lpr_supplier_name'] ) ) : '';
				$po_number = isset( $_POST['lpr_po_number'] ) ? sanitize_text_field( wp_unslash( $_POST['lpr_po_number'] ) ) : '';
				$eta       = isset( $_POST['lpr_eta_date'] ) ? lpr_allocator_sanitize_ymd( wp_unslash( $_POST['lpr_eta_date'] ) ) : '';
				$status    = isset( $_POST['lpr_po_status'] ) ? sanitize_key( wp_unslash( $_POST['lpr_po_status'] ) ) : PO_STATUS_OPEN;

				update_post_meta( $post_id, PO_META_SUPPLIER_NAME, $supplier );
				update_post_meta( $post_id, PO_META_PO_NUMBER, $po_number );
				update_post_meta( $post_id, PO_META_ETA_DATE, $eta );

				$allowed_status = array( PO_STATUS_OPEN, PO_STATUS_PARTIAL, PO_STATUS_CLOSED );
				if ( in_array( $status, $allowed_status, true ) && $post->post_status !== $status ) {
					self::$saving = true;
					remove_action( 'save_post', array( __CLASS__, 'save_post' ), 10 );
					wp_update_post(
						array(
							'ID'          => $post_id,
							'post_status' => $status,
						)
					);
					add_action( 'save_post', array( __CLASS__, 'save_post' ), 10, 2 );
					self::$saving = false;
				}
			}

			// Lines save.
			if ( isset( $_POST['lpr_po_lines_nonce'] ) && wp_verify_nonce( sanitize_text_field( wp_unslash( $_POST['lpr_po_lines_nonce'] ) ), 'lpr_po_lines_action' ) ) {
				$raw_lines = isset( $_POST['lpr_po_lines'] ) ? (array) $_POST['lpr_po_lines'] : array();
				$clean     = array();

				foreach ( $raw_lines as $row ) {
					$product_id   = isset( $row['product_id'] ) ? absint( $row['product_id'] ) : 0;
					$variation_id = isset( $row['variation_id'] ) ? absint( $row['variation_id'] ) : 0;
					$qty_ordered  = isset( $row['qty_ordered'] ) ? max( 0, (int) $row['qty_ordered'] ) : 0;
					$qty_alloc    = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
					$eta_override = isset( $row['eta_override'] ) ? lpr_allocator_sanitize_ymd( wp_unslash( $row['eta_override'] ) ) : '';
					$qty_recv     = isset( $row['qty_received'] ) ? max( 0, (int) $row['qty_received'] ) : 0;

					// At least one of product_id / variation_id must be valid product.
					$chosen_id    = $variation_id > 0 ? $variation_id : $product_id;
					if ( $chosen_id <= 0 || ! lpr_allocator_product_exists( $chosen_id ) ) {
						continue;
					}

					// Clamp allocations/received to ordered.
					if ( $qty_ordered > 0 ) {
						$qty_alloc = min( $qty_alloc, $qty_ordered );
						$qty_recv  = min( $qty_recv, $qty_ordered );
					} else {
						$qty_alloc = 0;
						$qty_recv  = 0;
					}

					$line = array(
						'qty_ordered'   => $qty_ordered,
						'qty_allocated' => $qty_alloc,
						'eta_override'  => $eta_override,
						'qty_received'  => $qty_recv,
					);

					// Persist whichever ID is provided; prefer variation if set.
					if ( $variation_id > 0 ) {
						$line['variation_id'] = $variation_id;
					} else {
						$line['product_id']   = $product_id;
					}

					$clean[] = $line;
				}

				update_post_meta( $post_id, PO_META_LINES, $clean );
			}
		}

		public static function columns( array $columns ): array {
			$new = array();
			$new['cb']        = isset( $columns['cb'] ) ? $columns['cb'] : '<input type="checkbox" />';
			$new['title']     = __( 'Title', 'lpr-backorder-allocator' );
			$new['po_number'] = __( 'PO #', 'lpr-backorder-allocator' );
			$new['supplier']  = __( 'Supplier', 'lpr-backorder-allocator' );
			$new['eta']       = __( 'ETA', 'lpr-backorder-allocator' );
			$new['lines']     = __( 'Lines', 'lpr-backorder-allocator' );
			$new['allocated'] = __( 'Allocated', 'lpr-backorder-allocator' );
			$new['po_status'] = __( 'Status', 'lpr-backorder-allocator' );
			$new['date']      = isset( $columns['date'] ) ? $columns['date'] : __( 'Date', 'lpr-backorder-allocator' );
			return $new;
		}

		public static function column_content( string $column, int $post_id ): void {
			switch ( $column ) {
				case 'po_number':
					$po = (string) get_post_meta( $post_id, PO_META_PO_NUMBER, true );
					echo esc_html( $po );
					break;
				case 'supplier':
					$supplier = (string) get_post_meta( $post_id, PO_META_SUPPLIER_NAME, true );
					echo esc_html( $supplier );
					break;
				case 'eta':
					$eta = (string) get_post_meta( $post_id, PO_META_ETA_DATE, true );
					echo esc_html( $eta );
					break;
				case 'lines':
					$lines = get_post_meta( $post_id, PO_META_LINES, true );
					if ( ! is_array( $lines ) ) {
						$lines = array();
					}
					echo esc_html( (string) count( $lines ) );
					break;
				case 'allocated':
					$lines = get_post_meta( $post_id, PO_META_LINES, true );
					$sum   = 0;
					if ( is_array( $lines ) ) {
						foreach ( $lines as $l ) {
							$sum += isset( $l['qty_allocated'] ) ? max( 0, (int) $l['qty_allocated'] ) : 0;
						}
					}
					echo esc_html( (string) $sum );
					break;
				case 'po_status':
					$st = get_post_status( $post_id );
					$obj = get_post_status_object( $st );
					echo esc_html( $obj && isset( $obj->label ) ? $obj->label : $st );
					break;
			}
		}

		public static function display_states( array $states, \WP_Post $post ): array {
			if ( CPT_SUPPLIER_PO !== $post->post_type ) {
				return $states;
			}
			$map = array(
				PO_STATUS_OPEN    => __( 'Open', 'lpr-backorder-allocator' ),
				PO_STATUS_PARTIAL => __( 'Partial', 'lpr-backorder-allocator' ),
				PO_STATUS_CLOSED  => __( 'Closed', 'lpr-backorder-allocator' ),
			);
			if ( isset( $map[ $post->post_status ] ) ) {
				$states[] = $map[ $post->post_status ];
			}
			return $states;
		}
	}
	Supplier_PO_CPT::init();
}

/* SELF-CHECK:
- Added CPT `supplier_po` (admin-only UI under WooCommerce menu), custom statuses open/partial/closed via register_post_status.
- Header meta keys: _lpr_supplier_name, _lpr_po_number, _lpr_eta_date; Lines meta: _lpr_po_lines (array with product_id|variation_id, qty_ordered, qty_allocated, eta_override, qty_received default 0).
- Implemented two metaboxes: PO Header (includes status select) and PO Lines (add/remove rows with JS). Full nonce + capability checks.
- Admin list columns: PO #, Supplier, ETA, Lines, Allocated, Status. Values computed without raw SQL; products validated via Woo CRUD.
- No stock writes; HPOS-safe; no wildcard meta queries; bails on frontend due to early admin/cron check; all declarations guarded; no re-declarations of prior batch elements.
*/
namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() ) {
	return;
}

if ( ! class_exists( __NAMESPACE__ . '\Backorder' ) ) {
	/**
	 * Backorder detection utilities.
	 */
	class Backorder {

		/**
		 * Determine if an order item needs allocation.
		 *
		 * True when:
		 * - Order status ∈ settings order_statuses, and
		 * - Product allows backorders, and
		 * - (order item meta "Backordered" > 0 OR product->is_on_backorder($qty) is true)
		 *
		 * @param \WC_Order_Item_Product $item
		 * @return bool
		 */
		public static function needs_allocation( \WC_Order_Item_Product $item ): bool {
			if ( ! $item instanceof \WC_Order_Item_Product ) {
				return false;
			}

			$order_id = (int) $item->get_order_id();
			if ( $order_id <= 0 || ! function_exists( 'wc_get_order' ) ) {
				return false;
			}
			$order = wc_get_order( $order_id );
			if ( ! $order instanceof \WC_Order ) {
				return false;
			}

			$settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
			$status   = $order->get_status(); // bare slug like 'processing'
			if ( empty( $settings['order_statuses'] ) || ! in_array( $status, (array) $settings['order_statuses'], true ) ) {
				return false;
			}

			$product = $item->get_product();
			if ( ! $product instanceof \WC_Product ) {
				return false;
			}
			if ( ! method_exists( $product, 'backorders_allowed' ) || ! $product->backorders_allowed() ) {
				return false;
			}

			$qty = max( 0, (int) $item->get_quantity() );

			// Detect backordered amount from item meta if present.
			$meta_backordered = 0;
			foreach ( array( 'Backordered', '_backordered', 'backordered' ) as $k ) {
				$v = $item->get_meta( $k, true );
				if ( '' !== $v && null !== $v ) {
					$meta_backordered = max( $meta_backordered, (int) $v );
				}
			}

			$is_on_backorder = method_exists( $product, 'is_on_backorder' ) ? (bool) $product->is_on_backorder( $qty ) : ( $meta_backordered > 0 );

			return ( $meta_backordered > 0 || $is_on_backorder );
		}
	}
}

if ( ! class_exists( __NAMESPACE__ . '\ETA' ) ) {
	/**
	 * ETA computation & persistence.
	 */
	class ETA {

		/**
		 * Re-entrancy guard.
		 * @var bool
		 */
		protected static $updating = false;

		/**
		 * Compute earliest ETA over non-released allocations for each order line
		 * and persist to ORDER_ITEM_META_LINE_ETA (Y-m-d).
		 *
		 * @param int $order_id
		 * @return void
		 */
		
		/**
 * Get the current ETA for this item from the given PO:
 * - If the PO has a line for this product/variation with an 'eta_override', use that.
 * - Otherwise, use the PO header ETA.
 */
public static function live_eta_from_po( int $po_id, \WC_Order_Item_Product $item ): string {
	if ( $po_id <= 0 || ! ( $item instanceof \WC_Order_Item_Product ) ) {
		return '';
	}
	$target_id = (int) $item->get_variation_id();
	if ( $target_id <= 0 ) {
		$target_id = (int) $item->get_product_id();
	}
	if ( $target_id <= 0 ) {
		return '';
	}

	$lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
	if ( is_array( $lines ) ) {
		foreach ( $lines as $line ) {
			$vid = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
			$pid = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
			$tid = $vid > 0 ? $vid : $pid;
			if ( $tid === $target_id ) {
				$eta_override = isset( $line['eta_override'] ) ? lpr_allocator_sanitize_ymd( (string) $line['eta_override'] ) : '';
				if ( '' !== $eta_override ) {
					return $eta_override;
				}
				break; // matching line found but no override - fall back to header ETA
			}
		}
	}

	$po_eta = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true );
	return lpr_allocator_sanitize_ymd( (string) $po_eta );
}
		// inside class ETA { ... }

// REPLACE update_line_eta() with this version
public static function update_line_eta( int $order_id ): void {
	if ( self::$updating ) {
		return;
	}
	if ( ! function_exists( 'wc_get_order' ) || $order_id <= 0 ) {
		return;
	}

	$order = wc_get_order( $order_id );
	if ( ! $order instanceof \WC_Order ) {
		return;
	}

	self::$updating = true;

	$items    = $order->get_items( 'line_item' );
	$changes  = array(); // collect changes to email once per order

	foreach ( $items as $item ) {
		if ( ! $item instanceof \WC_Order_Item_Product ) {
			continue;
		}
		$allocs = $item->get_meta( defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations', true );
		if ( ! is_array( $allocs ) ) {
			$allocs = array();
		}

		$etas = array();

		foreach ( $allocs as $row ) {
			$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
			if ( 'released' === $status ) {
				continue;
			}

			$eta   = '';
			$po_id = isset( $row['po_id'] ) ? (int) $row['po_id'] : 0;

			if ( $po_id > 0 ) {
				// Always use the current PO value (line override > PO header)
				$eta = self::live_eta_from_po( $po_id, $item );
			} else {
				// Non-PO allocations: use stored row ETA if present
				if ( ! empty( $row['eta'] ) ) {
					$eta = lpr_allocator_sanitize_ymd( (string) $row['eta'] );
				}
			}

			if ( '' !== $eta ) {
				$etas[] = $eta;
			}
		}

		$new_eta = '';
		if ( ! empty( $etas ) ) {
			sort( $etas, SORT_STRING ); // Y-m-d lexical sort is chronological
			$new_eta = (string) $etas[0];
		}

		$meta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA' ) ? ORDER_ITEM_META_LINE_ETA : '_lpr_line_eta';
		$prev_eta = (string) $item->get_meta( $meta_key, true );

		if ( $prev_eta !== $new_eta ) {
			// Persist new ETA
			$item->update_meta_data( $meta_key, $new_eta );
			$item->save();

			// Private order note (always)
			$product = $item->get_product();
			$sku     = $product instanceof \WC_Product ? $product->get_sku() : '';
			$from    = $prev_eta !== '' ? $prev_eta : '—';
			$to      = $new_eta  !== '' ? $new_eta  : '—';

			$order->add_order_note(
				sprintf(
					/* translators: 1: item name, 2: SKU, 3: from ETA, 4: to ETA */
					__( 'ETA changed for %1$s%2$s: %3$s → %4$s.', 'lpr-backorder-allocator' ),
					$item->get_name(),
					$sku ? ' [' . $sku . ']' : '',
					$from,
					$to
				),
				false, // private
				true
			);

			// Queue for optional customer email (we’ll send once per order)
			$changes[] = array(
				'name' => $item->get_name() . ( $sku ? ' [' . $sku . ']' : '' ),
				'prev' => $from,
				'new'  => $to,
			);
		}
	}

	// Optional email once per order
	if ( ! empty( $changes ) ) {
		self::maybe_email_eta_changes( $order, $changes );
	}

	self::$updating = false;
}

// ADD this helper just below update_line_eta()
protected static function maybe_email_eta_changes( \WC_Order $order, array $changes ): void {
	// Respect settings toggle
	$settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array();
	if ( empty( $settings['inform_customer_eta'] ) ) {
		return;
	}
	$email = $order->get_billing_email();
	if ( ! $email ) {
		return;
	}

	$logo  = (string) ( $settings['brand_logo_url']       ?? '' );
	$color = (string) ( $settings['brand_primary_color']  ?? '#1a1a1a' );
	$foot  = (string) ( $settings['email_footer_text_no'] ?? '' );

	$subject = __( 'Your order ETA has been updated', 'lpr-backorder-allocator' );

	$logo_html = $logo ? '<div style="margin-bottom:12px;"><img src="' . esc_url( $logo ) . '" style="max-height:40px;" alt="" /></div>' : '';
	$body  = '<div style="font-family:Arial,Helvetica,sans-serif;">' . $logo_html;
	$body .= '<h2 style="color:' . esc_attr( $color ) . ';margin:0 0 12px 0;">' . esc_html( $subject ) . '</h2>';
	$body .= '<p>' . esc_html__( 'We’ve updated the expected arrival for the items below:', 'lpr-backorder-allocator' ) . '</p>';

	$body .= '<table cellspacing="0" cellpadding="6" border="0" style="width:100%;border-collapse:collapse;">';
	$body .= '<thead><tr><th align="left">' . esc_html__( 'Item', 'lpr-backorder-allocator' ) . '</th><th align="left">' . esc_html__( 'Previous', 'lpr-backorder-allocator' ) . '</th><th align="left">' . esc_html__( 'New ETA', 'lpr-backorder-allocator' ) . '</th></tr></thead><tbody>';
	foreach ( $changes as $c ) {
		$body .= '<tr><td>' . esc_html( (string) $c['name'] ) . '</td><td>' . esc_html( (string) $c['prev'] ) . '</td><td>' . esc_html( (string) $c['new'] ) . '</td></tr>';
	}
	$body .= '</tbody></table>';

	if ( $foot ) {
		$body .= '<p style="margin-top:16px;color:#777;font-size:12px;">' . wp_kses_post( $foot ) . '</p>';
	}
	$body .= '</div>';

	if ( function_exists( 'wc_mail' ) ) {
		wc_mail( $email, $subject, $body, array( 'Content-Type: text/html; charset=UTF-8' ) );
	} else {
		wp_mail( $email, $subject, $body, array( 'Content-Type: text/html; charset=UTF-8' ) );
	}
}

		/**
		 * Hook: update ETA when orders save (classic + HPOS).
		 */
		public static function init_hooks(): void {
			// Classic posts screen.
			add_action(
				'save_post_shop_order',
				static function ( $post_id, $post ) {
					if ( self::$updating ) {
						return;
					}
					if ( ! current_user_can( 'manage_woocommerce' ) ) {
						return;
					}
					if ( $post && 'shop_order' === $post->post_type ) {
						self::update_line_eta( (int) $post_id );
					}
				},
				20,
				2
			);

			// HPOS data store.
			add_action(
				'woocommerce_after_order_object_save',
				static function ( $order ) {
					if ( self::$updating ) {
						return;
					}
					if ( $order instanceof \WC_Order ) {
						self::update_line_eta( (int) $order->get_id() );
					}
				},
				20,
				1
			);
		}
	}
	ETA::init_hooks();
}

if ( ! class_exists( __NAMESPACE__ . '\Order_Allocations_Metabox' ) ) {
	/**
	 * Order admin metabox rendering allocations & ETA per line.
	 */
	class Order_Allocations_Metabox {

		public static function init(): void {
			add_action( 'add_meta_boxes', array( __CLASS__, 'register_box' ), 20 );
			// Extra registrations to better support HPOS screen routing.
			add_action( 'add_meta_boxes_shop_order', array( __CLASS__, 'register_box' ), 20 );
			add_action( 'add_meta_boxes_woocommerce_page_wc-orders', array( __CLASS__, 'register_box' ), 20 );
		}

		public static function register_box(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			add_meta_box(
				'lpr_order_allocations_eta',
				__( 'Allocations & ETA', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_box' ),
				'shop_order',
				'normal',
				'default'
			);

			// HPOS screen support (screen id acts as $post_type).
			add_meta_box(
				'lpr_order_allocations_eta',
				__( 'Allocations & ETA', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_box' ),
				'woocommerce_page_wc-orders',
				'normal',
				'default'
			);
		}

		/**
		 * Resolve order ID from context (classic & HPOS edit screens).
		 *
		 * @param mixed $context
		 * @return int
		 */
		protected static function resolve_order_id( $context ): int {
			$order_id = 0;
			if ( $context instanceof \WP_Post ) {
				$order_id = (int) $context->ID;
			}
			if ( $order_id <= 0 && isset( $_GET['id'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				$order_id = absint( $_GET['id'] ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			}
			return $order_id;
		}

		public static function render_box( $post_or_screen ): void {
			if ( ! function_exists( 'wc_get_order' ) ) {
				return;
			}
			$order_id = self::resolve_order_id( $post_or_screen );
			if ( $order_id <= 0 ) {
				echo '<p>' . esc_html__( 'Order not found.', 'lpr-backorder-allocator' ) . '</p>';
				return;
			}

			// Persist latest ETA before rendering.
			if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
				ETA::update_line_eta( $order_id );
			}

			$order = wc_get_order( $order_id );
			if ( ! $order instanceof \WC_Order ) {
				echo '<p>' . esc_html__( 'Order not found.', 'lpr-backorder-allocator' ) . '</p>';
			 return;
			}

			$items = $order->get_items( 'line_item' );

			// Basic styles.
			$css  = '.lpr-alloc-eta{width:100%;border-collapse:collapse}.lpr-alloc-eta th,.lpr-alloc-eta td{padding:6px;border-bottom:1px solid #ddd;text-align:left}';
			$css .= '.lpr-alloc-sub{margin:6px 0 0 0;border-collapse:collapse;width:100%}.lpr-alloc-sub th,.lpr-alloc-sub td{padding:4px;border-bottom:1px solid #eee;font-size:12px}';
			$css .= '.lpr-badge{display:inline-block;padding:2px 6px;border-radius:3px;background:#f0ad4e;color:#111;font-size:11px;margin-left:6px}';
			$css .= '.lpr-unallocated{font-style:italic;opacity:0.8}';
			echo '<style type="text/css">' . esc_html( $css ) . '</style>';

			echo '<table class="widefat striped lpr-alloc-eta">';
			echo '<thead><tr>';
			echo '<th>' . esc_html__( 'Item', 'lpr-backorder-allocator' ) . '</th>';
			echo '<th>' . esc_html__( 'Qty', 'lpr-backorder-allocator' ) . '</th>';
			echo '<th>' . esc_html__( 'ETA', 'lpr-backorder-allocator' ) . '</th>';
			echo '<th>' . esc_html__( 'Allocations', 'lpr-backorder-allocator' ) . '</th>';
			echo '</tr></thead><tbody>';

			foreach ( $items as $item ) {
				if ( ! $item instanceof \WC_Order_Item_Product ) {
					continue;
				}

				$product   = $item->get_product();
				$name      = $item->get_name();
				$qty       = (int) $item->get_quantity();
				$sku       = $product instanceof \WC_Product ? $product->get_sku() : '';
				$line_eta  = (string) $item->get_meta( defined( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA' ) ? ORDER_ITEM_META_LINE_ETA : '_lpr_line_eta', true );
				$allocs    = $item->get_meta( defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations', true );
				$needs     = class_exists( __NAMESPACE__ . '\Backorder' ) ? Backorder::needs_allocation( $item ) : false;

				echo '<tr>';
				echo '<td>';
				echo esc_html( $name );
				if ( $sku ) {
					echo ' <small>#' . esc_html( $sku ) . '</small>';
				}
				if ( $needs ) {
					echo ' <span class="lpr-badge">' . esc_html__( 'Backorder', 'lpr-backorder-allocator' ) . '</span>';
				}
				echo '</td>';

				echo '<td>' . esc_html( (string) $qty ) . '</td>';

				if ( $line_eta ) {
					echo '<td>' . esc_html( $line_eta ) . '</td>';
				} else {
					echo '<td class="lpr-unallocated">' . esc_html__( 'Unallocated', 'lpr-backorder-allocator' ) . '</td>';
				}

				echo '<td>';
				if ( is_array( $allocs ) && ! empty( $allocs ) ) {
					echo '<table class="lpr-alloc-sub"><thead><tr>';
					echo '<th>' . esc_html__( 'PO #', 'lpr-backorder-allocator' ) . '</th>';
					echo '<th>' . esc_html__( 'Qty', 'lpr-backorder-allocator' ) . '</th>';
					echo '<th>' . esc_html__( 'ETA', 'lpr-backorder-allocator' ) . '</th>';
					echo '<th>' . esc_html__( 'Status', 'lpr-backorder-allocator' ) . '</th>';
					echo '</tr></thead><tbody>';

					foreach ( $allocs as $row ) {
						$po_id     = isset( $row['po_id'] ) ? absint( $row['po_id'] ) : 0;
						$po_number = isset( $row['po_number'] ) ? (string) $row['po_number'] : ( $po_id ? (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', true ) : '' );
						$alloc_q   = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
						$eta_row   = '';
						if ( ! empty( $row['eta'] ) ) {
							$eta_row = lpr_allocator_sanitize_ymd( (string) $row['eta'] );
						}
						if ( '' === $eta_row && $po_id ) {
							$eta_row = lpr_allocator_sanitize_ymd( (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true ) );
						}
						$status    = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';

						echo '<tr>';
						echo '<td>' . esc_html( $po_number ) . '</td>';
						echo '<td>' . esc_html( (string) $alloc_q ) . '</td>';
						echo '<td>' . esc_html( $eta_row ) . '</td>';
						echo '<td>' . esc_html( $status ) . '</td>';
						echo '</tr>';
					}

					echo '</tbody></table>';
				} else {
					echo '<span class="lpr-unallocated">' . esc_html__( 'No allocations', 'lpr-backorder-allocator' ) . '</span>';
				}
				echo '</td>';

				echo '</tr>';
			}

			echo '</tbody></table>';
		}
	}
	Order_Allocations_Metabox::init();
}

/* SELF-CHECK:
- Added Backorder::needs_allocation(WC_Order_Item_Product) using settings order_statuses, product->backorders_allowed(), and Backordered meta / is_on_backorder($qty).
- Added ETA::update_line_eta($order_id) to compute earliest Y-m-d ETA across non-released allocations and persist to _lpr_line_eta; hooked on order save (classic + HPOS) with re-entrancy guard.
- Added admin-only "Allocations & ETA" metabox for orders (classic + HPOS screen ids). Shows per-line ETA or "Unallocated" and lists allocation rows (PO #, qty, ETA, status).
- All declarations are guarded; HPOS-safe (Woo CRUD only); no frontend hooks; no stock writes; no wildcard meta queries.
*/
namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() ) {
	return;
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_product_option_label' ) ) {
	/**
	 * Build a readable option label for a product/variation.
	 *
	 * @param int $id Product or variation ID.
	 * @return string
	 */
	function lpr_allocator_product_option_label( int $id ): string {
		if ( ! function_exists( 'wc_get_product' ) ) {
			return '#' . $id;
		}
		$product = wc_get_product( $id );
		if ( ! $product instanceof \WC_Product ) {
			return '#' . $id;
		}
		$name = wp_strip_all_tags( $product->get_formatted_name() );
		$sku  = $product->get_sku();
		if ( $sku ) {
			$name .= ' (' . $sku . ')';
		}
		return $name;
	}
}

if ( ! class_exists( __NAMESPACE__ . '\Supplier_PO_Live_Product_UI' ) ) {
	/**
	 * Overrides the PO Lines metabox to use Woo's live product (and variations) search.
	 * Does not alter storage format; on save, existing handler in Supplier_PO_CPT::save_post remains in charge.
	 */
	class Supplier_PO_Live_Product_UI {

		public static function init(): void {
			// Swap the original PO Lines metabox for our live-search version (run after original registration).
			add_action( 'add_meta_boxes', array( __CLASS__, 'swap_lines_metabox' ), 100 );
			// Enqueue Woo enhanced select on our CPT screen.
			add_action( 'admin_enqueue_scripts', array( __CLASS__, 'enqueue_assets' ) );
			// Preprocess posted lines (server-side safety): map select_id -> product_id/variation_id before original save handler runs.
			add_action( 'save_post', array( __CLASS__, 'preprocess_save' ), 5, 2 );
		}

		/**
		 * Remove original lines box and add our enhanced one.
		 */
		public static function swap_lines_metabox(): void {
			remove_meta_box( 'lpr_po_lines', defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po', 'normal' );
			add_meta_box(
				'lpr_po_lines',
				__( 'PO Lines (Live Product Search)', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_lines_metabox_live' ),
				defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
				'normal',
				'default'
			);
		}

		/**
		 * Enqueue WooCommerce enhanced select assets on our CPT screen.
		 */
		public static function enqueue_assets( $hook ): void {
			$screen = function_exists( 'get_current_screen' ) ? get_current_screen() : null;
			if ( $screen && isset( $screen->post_type ) && $screen->post_type === ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) ) {
				// Core Woo assets (already registered by Woo).
				wp_enqueue_style( 'woocommerce_admin_styles' );
				wp_enqueue_script( 'wc-enhanced-select' ); // loads SelectWoo + init event
			}
		}

		/**
		 * Render the enhanced PO lines box with live product search.
		 */
		public static function render_lines_metabox_live( \WP_Post $post ): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			wp_nonce_field( 'lpr_po_lines_action', 'lpr_po_lines_nonce' );
			$lines = get_post_meta( $post->ID, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
			if ( ! is_array( $lines ) ) {
				$lines = array();
			}

			?>
			<style>
				#lpr_po_lines table { width: 100%; border-collapse: collapse; }
				#lpr_po_lines th, #lpr_po_lines td { border-bottom: 1px solid #ddd; padding: 6px; text-align:left; vertical-align: top; }
				#lpr_po_lines .actions { text-align: right; margin-top: 8px; }
				#lpr_po_lines input[type="number"] { width: 110px; }
				#lpr_po_lines input[type="text"] { width: 170px; }
				#lpr_po_lines .lpr-product-cell .select2-container { min-width: 320px; }
			</style>
			<table class="widefat striped" id="lpr-po-lines-table">
				<thead>
					<tr>
						<th><?php echo esc_html__( 'Product / Variation', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Qty Ordered', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Qty Allocated', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'ETA Override (Y-m-d)', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Qty Received', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Remove', 'lpr-backorder-allocator' ); ?></th>
					</tr>
				</thead>
				<tbody>
					<?php
					$idx = 0;
					foreach ( $lines as $line ) :
						$product_id   = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
						$variation_id = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
						$chosen_id    = $variation_id > 0 ? $variation_id : $product_id;
						$qty_ordered  = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
						$qty_alloc    = isset( $line['qty_allocated'] ) ? max( 0, (int) $line['qty_allocated'] ) : 0;
						$eta_override = isset( $line['eta_override'] ) ? (string) $line['eta_override'] : '';
						$qty_recv     = isset( $line['qty_received'] ) ? max( 0, (int) $line['qty_received'] ) : 0;

						$label = $chosen_id ? lpr_allocator_product_option_label( $chosen_id ) : '';
						?>
						<tr>
							<td class="lpr-product-cell">
								<select
									class="wc-product-search lpr-product-select"
									name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][select_ui]"
									data-placeholder="<?php echo esc_attr__( 'Search for a product…', 'lpr-backorder-allocator' ); ?>"
									data-action="woocommerce_json_search_products_and_variations"
									data-minimum_input_length="1"
									data-allow_clear="true"
									style="min-width: 320px;"
								>
									<?php if ( $chosen_id ) : ?>
										<option value="<?php echo esc_attr( (string) $chosen_id ); ?>" selected="selected">
											<?php echo esc_html( $label ); ?>
										</option>
									<?php endif; ?>
								</select>
								<input type="hidden" class="lpr-select-id" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][select_id]" value="<?php echo esc_attr( (string) $chosen_id ); ?>" />
								<input type="hidden" class="lpr-product-id" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][product_id]" value="<?php echo esc_attr( (string) $product_id ); ?>" />
								<input type="hidden" class="lpr-variation-id" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][variation_id]" value="<?php echo esc_attr( (string) $variation_id ); ?>" />
							</td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][qty_ordered]" value="<?php echo esc_attr( (string) $qty_ordered ); ?>" /></td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][qty_allocated]" value="<?php echo esc_attr( (string) $qty_alloc ); ?>" /></td>
							<td><input type="text" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][eta_override]" value="<?php echo esc_attr( $eta_override ); ?>" placeholder="YYYY-MM-DD" /></td>
							<td><input type="number" min="0" step="1" name="lpr_po_lines[<?php echo esc_attr( $idx ); ?>][qty_received]" value="<?php echo esc_attr( (string) $qty_recv ); ?>" /></td>
							<td><button type="button" class="button link-delete lpr-remove-line"><?php echo esc_html__( 'Remove', 'lpr-backorder-allocator' ); ?></button></td>
						</tr>
						<?php
						$idx++;
					endforeach;
					?>
				</tbody>
			</table>
			<div class="actions">
				<button type="button" class="button button-secondary" id="lpr-add-line"><?php echo esc_html__( 'Add Line', 'lpr-backorder-allocator' ); ?></button>
			</div>
			<script>
				(function($){
					function initEnhancedSelect(context){
						$(document.body).trigger('wc-enhanced-select-init');
						// Bind change to keep hidden IDs in sync for each row.
						$(context).find('select.lpr-product-select').off('change.lpr').on('change.lpr', function(){
							var $sel = $(this),
								val  = $sel.val() || '';
							var $row = $sel.closest('tr');
							$row.find('input.lpr-select-id').val(val);
							// Optimistic client-side guess: set product_id to selected id; server will correct to variation_id if needed.
							$row.find('input.lpr-product-id').val(val);
							$row.find('input.lpr-variation-id').val('');
						});
					}
					function nextIndex($tbody){
						let max = -1;
						$tbody.find('tr').each(function(){
							const first = $(this).find('input[name^="lpr_po_lines["], select[name^="lpr_po_lines["]').first();
							const m = first.attr('name') && first.attr('name').match(/^lpr_po_lines\[(\d+)\]/);
							if(m){ max = Math.max(max, parseInt(m[1],10)); }
						});
						return max + 1;
					}
					const $tbody = $('#lpr-po-lines-table').find('tbody');
					$('#lpr-add-line').on('click', function(e){
						e.preventDefault();
						const i = nextIndex($tbody);
						const rowHtml =
							'<tr>' +
								'<td class="lpr-product-cell">' +
									'<select class="wc-product-search lpr-product-select" name="lpr_po_lines['+i+'][select_ui]" data-placeholder="<?php echo esc_js( __( 'Search for a product…', 'lpr-backorder-allocator' ) ); ?>" data-action="woocommerce_json_search_products_and_variations" data-minimum_input_length="1" data-allow_clear="true" style="min-width:320px;"></select>' +
									'<input type="hidden" class="lpr-select-id" name="lpr_po_lines['+i+'][select_id]" value="" />' +
									'<input type="hidden" class="lpr-product-id" name="lpr_po_lines['+i+'][product_id]" value="" />' +
									'<input type="hidden" class="lpr-variation-id" name="lpr_po_lines['+i+'][variation_id]" value="" />' +
								'</td>' +
								'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][qty_ordered]" value="0" /></td>' +
								'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][qty_allocated]" value="0" /></td>' +
								'<td><input type="text" name="lpr_po_lines['+i+'][eta_override]" value="" placeholder="YYYY-MM-DD" /></td>' +
								'<td><input type="number" min="0" step="1" name="lpr_po_lines['+i+'][qty_received]" value="0" /></td>' +
								'<td><button type="button" class="button link-delete lpr-remove-line"><?php echo esc_js( __( 'Remove', 'lpr-backorder-allocator' ) ); ?></button></td>' +
							'</tr>';
						const $row = $(rowHtml).appendTo($tbody);
						initEnhancedSelect($row);
					});
					$tbody.on('click', '.lpr-remove-line', function(e){
						e.preventDefault();
						$(this).closest('tr').remove();
					});
					// Initialize existing selects.
					initEnhancedSelect($tbody);
					// Ensure hidden select_id is populated before submit.
					$('#post').on('submit', function(){
						$tbody.find('select.lpr-product-select').each(function(){
							var val = $(this).val() || '';
							var $row = $(this).closest('tr');
							$row.find('input.lpr-select-id').val(val);
							if(!val){
								// If empty ensure IDs are cleared to prevent stale values.
								$row.find('input.lpr-product-id, input.lpr-variation-id').val('');
							}
						});
					});
				})(jQuery);
			</script>
			<p class="description">
				<?php echo esc_html__( 'Use the live search to pick any product or variation. Received defaults to 0. Allocation is a ledger only; no stock writes.', 'lpr-backorder-allocator' ); ?>
			</p>
			<?php
		}

		/**
		 * Server-side safety: translate posted select_id into product_id or variation_id
		 * so the existing Supplier_PO_CPT::save_post logic can validate & persist correctly.
		 */
		public static function preprocess_save( int $post_id, \WP_Post $post ): void {
			if ( ( defined( 'DOING_AUTOSAVE' ) && DOING_AUTOSAVE ) || wp_is_post_revision( $post_id ) ) {
				return;
			}
			if ( ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
				return;
			}
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			// Only proceed if our nonce is present/valid (same as main save handler).
			if ( empty( $_POST['lpr_po_lines_nonce'] ) || ! wp_verify_nonce( sanitize_text_field( wp_unslash( $_POST['lpr_po_lines_nonce'] ) ), 'lpr_po_lines_action' ) ) {
				return;
			}
			if ( empty( $_POST['lpr_po_lines'] ) || ! is_array( $_POST['lpr_po_lines'] ) ) {
				return;
			}
			$lines = &$_POST['lpr_po_lines']; // phpcs:ignore WordPress.Security.NonceVerification.Missing
			foreach ( $lines as $idx => &$row ) {
				if ( ! is_array( $row ) ) {
					continue;
				}
				$sel_id = isset( $row['select_id'] ) ? absint( $row['select_id'] ) : 0;
				// Only normalize when both product_id and variation_id are empty or zero.
				$pid    = isset( $row['product_id'] ) ? absint( $row['product_id'] ) : 0;
				$vid    = isset( $row['variation_id'] ) ? absint( $row['variation_id'] ) : 0;

				if ( $sel_id && 0 === $pid && 0 === $vid && function_exists( 'wc_get_product' ) ) {
					$p = wc_get_product( $sel_id );
					if ( $p instanceof \WC_Product ) {
						if ( $p->is_type( 'variation' ) ) {
							$row['variation_id'] = (string) $sel_id;
							$row['product_id']   = '';
						} else {
							$row['product_id']   = (string) $sel_id;
							$row['variation_id'] = '';
						}
					}
				}
			}
			unset( $row ); // break reference
		}
	}
	Supplier_PO_Live_Product_UI::init();
}

/* SELF-CHECK:
- Added Supplier_PO_Live_Product_UI class to replace the PO Lines metabox with a fast live product/variation search using Woo's `wc-enhanced-select` and the `woocommerce_json_search_products_and_variations` AJAX endpoint (covers all product types & variations).
- Kept storage contract intact: we still save meta `_lpr_po_lines` lines with `{product_id|variation_id, qty_ordered, qty_allocated, eta_override, qty_received}`. We do not write stock.
- Implemented `preprocess_save()` (priority 5) to map posted `select_id` to `product_id` or `variation_id` server-side so the existing `Supplier_PO_CPT::save_post()` validation & persistence continue to work without re-declaration. Also includes nonce/cap checks.
- Enqueued Woo admin assets only on the Supplier PO screen; no frontend hooks; admin/cron-only check kept at file top.
- Performance: relies on Woo’s optimized JSON search; no wildcard meta_query in our code; batch UI handling only. HPOS-safe (CRUD via wc_get_product); no raw SQL.
- Security: capabilities checked, nonces verified, all user input sanitized/escaped.
- Helper function added `lpr_allocator_product_option_label()` (guarded) for preselected labels.
- Existing features intact: Settings tab (WooCommerce → Settings → Backorders), CPT "Supplier POs" admin screens (list + edit with live search), Order admin metabox "Allocations & ETA".
- Avoided re-declarations by using a new class and removing+re-adding only the specific metabox via hooks.
*/
namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() ) {
	return;
}

if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_need' ) ) {
	/**
	 * Calculate remaining backordered qty for an order item (ledger-aware).
	 * Uses item meta "Backordered" when present; otherwise assumes full line qty if product reports on-backorder.
	 *
	 * @param \WC_Order_Item_Product $item
	 * @return int Remaining units needing allocation (>=0).
	 */
	function lpr_allocator_calc_backorder_need( \WC_Order_Item_Product $item ): int {
		if ( ! $item instanceof \WC_Order_Item_Product ) {
			return 0;
		}
		$qty = max( 0, (int) $item->get_quantity() );
		$product = $item->get_product();
		if ( ! ( $product instanceof \WC_Product ) ) {
			return 0;
		}

		// Desired backorder amount from item meta if present.
		$desired = 0;
		foreach ( array( 'Backordered', '_backordered', 'backordered' ) as $k ) {
			$v = $item->get_meta( $k, true );
			if ( '' !== $v && null !== $v ) {
				$desired = max( $desired, (int) $v );
			}
		}
		if ( 0 === $desired && method_exists( $product, 'is_on_backorder' ) && $product->is_on_backorder( $qty ) ) {
			$desired = $qty; // fallback when exact backordered count unknown
		}

		// Subtract existing active allocations (non-released).
		$allocs = $item->get_meta( defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations', true );
		$allocated_active = 0;
		if ( is_array( $allocs ) ) {
			foreach ( $allocs as $row ) {
				$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
				if ( 'released' === $status ) {
					continue;
				}
				$allocated_active += isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
			}
		}

		$need = max( 0, $desired - $allocated_active );
		// Hard cap to line item qty for safety.
		$need = min( $need, $qty );

		return $need;
	}
}

if ( ! class_exists( __NAMESPACE__ . '\PO_FIFO_Allocator' ) ) {
	/**
	 * FIFO allocator that assigns PO quantities to backordered order items (ledger only).
	 */
	class PO_FIFO_Allocator {

		/**
		 * Hook registrations.
		 */
		public static function init(): void {
			// Admin-post handler for the Allocate button.
			add_action( 'admin_post_lpr_allocate_po', array( __CLASS__, 'handle_allocate_request' ) );

			// Action Scheduler consumer (async). Group: lpr-allocator.
			add_action( 'lpr_allocator_allocate_po', array( __CLASS__, 'allocate_po' ), 10, 1 );
		}

		/**
		 * Handle Allocate button click from PO screen.
		 */
		public static function handle_allocate_request(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) );
			}
			$po_id = isset( $_GET['po_id'] ) ? absint( $_GET['po_id'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			$nonce = isset( $_GET['_wpnonce'] ) ? (string) $_GET['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

			if ( $po_id <= 0 || ! wp_verify_nonce( $nonce, 'lpr_allocate_po_' . $po_id ) ) {
				wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
			}

			$redirect = get_edit_post_link( $po_id, 'url' );
			$queued   = false;

			// Prefer async queue; fallback to inline if Action Scheduler unavailable.
			if ( function_exists( 'as_enqueue_async_action' ) ) {
				as_enqueue_async_action( 'lpr_allocator_allocate_po', array( 'po_id' => $po_id ), 'lpr-allocator' );
				$queued = true;
			} elseif ( function_exists( 'as_schedule_single_action' ) ) {
				as_schedule_single_action( time(), 'lpr_allocator_allocate_po', array( 'po_id' => $po_id ), 'lpr-allocator' );
				$queued = true;
			} else {
				// Inline execution.
				self::allocate_po( $po_id );
			}

			wp_safe_redirect( add_query_arg( array( 'lpr_alloc' => $queued ? 'queued' : 'done' ), $redirect ) );
			exit;
		}

		/**
		 * Allocate a single PO across backordered items in FIFO order.
		 *
		 * @param int $po_id
		 * @return void
		 */
		public static function allocate_po( int $po_id ): void {
			$po = get_post( $po_id );
			if ( ! ( $po instanceof \WP_Post ) || ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $po->post_type ) {
				return;
			}

			// Load PO lines and header defaults.
			$lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
			if ( ! is_array( $lines ) || empty( $lines ) ) {
				return;
			}
			$po_number = (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', true );
			$po_eta    = (string) get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', true );

			$affected_orders = array(); // order_id => true

			// Process each PO line independently with a per-SKU lock to avoid contention.
			foreach ( $lines as $idx => $line ) {
				$qty_ordered   = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
				$qty_allocated = isset( $line['qty_allocated'] ) ? max( 0, (int) $line['qty_allocated'] ) : 0;
				$eta_override  = isset( $line['eta_override'] ) ? lpr_allocator_sanitize_ymd( (string) $line['eta_override'] ) : '';
				$variation_id  = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
				$product_id    = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;

				// Choose target (prioritize variation).
				$target_id = $variation_id > 0 ? $variation_id : $product_id;
				if ( $target_id <= 0 || ! lpr_allocator_product_exists( $target_id ) ) {
					continue;
				}

				$remaining_for_line = max( 0, $qty_ordered - $qty_allocated );
				if ( $remaining_for_line <= 0 ) {
					continue;
				}

				$product = wc_get_product( $target_id );
				if ( ! ( $product instanceof \WC_Product ) ) {
					continue;
				}
				$sku = $product->get_sku();
				$lock_key = 'lpr_alloc_lock_' . md5( $sku ? 'sku:' . $sku : 'id:' . $target_id );
				if ( get_transient( $lock_key ) ) {
					// Another process is working this SKU; skip this line for now.
					continue;
				}
				set_transient( $lock_key, 1, 60 ); // short-lived lock

				try {
					$allocated_total = self::allocate_for_single_line(
						$po_id,
						$po_number,
						$po_eta,
						$target_id,
						$remaining_for_line,
						$eta_override,
						$affected_orders
					);

					// Increment line's qty_allocated and persist back to meta array.
					if ( $allocated_total > 0 ) {
						$lines[ $idx ]['qty_allocated'] = $qty_allocated + $allocated_total;
					}
				} finally {
					delete_transient( $lock_key );
				}
			}

			// Persist updated lines only once.
			update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', $lines );

			// Recompute ETAs for all affected orders (one pass).
			if ( ! empty( $affected_orders ) && class_exists( __NAMESPACE__ . '\ETA' ) ) {
				foreach ( array_keys( $affected_orders ) as $oid ) {
					ETA::update_line_eta( (int) $oid );
				}
			}
		}

		/**
		 * Allocate a single PO line across backordered order items in FIFO order.
		 *
		 * @param int      $po_id
		 * @param string   $po_number
		 * @param string   $po_eta_header
		 * @param int      $target_product_or_variation_id
		 * @param int      $remaining_for_line
		 * @param string   $eta_override
		 * @param string[] $affected_orders Reference accumulator.
		 * @return int Total quantity allocated from this line.
		 */
		protected static function allocate_for_single_line( int $po_id, string $po_number, string $po_eta_header, int $target_product_or_variation_id, int $remaining_for_line, string $eta_override, array &$affected_orders ): int {
			if ( $remaining_for_line <= 0 ) {
				return 0;
			}

			// Build FIFO queue of candidate line items needing allocation.
			$queue = self::build_fifo_queue( $target_product_or_variation_id, $remaining_for_line );

			if ( empty( $queue ) ) {
				return 0;
			}

			$allocated_total = 0;
			$meta_key_allocs = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
			$today_dt        = current_time( 'mysql' );
			$eta_to_store    = $eta_override ? $eta_override : lpr_allocator_sanitize_ymd( $po_eta_header );

			foreach ( $queue as $entry ) {
				if ( $remaining_for_line <= 0 ) {
					break;
				}
				$order = wc_get_order( $entry['order_id'] );
				if ( ! ( $order instanceof \WC_Order ) ) {
					continue;
				}

				// Locate the target item by id.
				$target_item = null;
				foreach ( $order->get_items( 'line_item' ) as $it ) {
					if ( $it->get_id() === $entry['item_id'] ) {
						$target_item = $it;
						break;
					}
				}
				if ( ! ( $target_item instanceof \WC_Order_Item_Product ) ) {
					continue;
				}

				$need_for_item = lpr_allocator_calc_backorder_need( $target_item );
				if ( $need_for_item <= 0 ) {
					continue;
				}

				$allocate_now = min( $need_for_item, $remaining_for_line );
				if ( $allocate_now <= 0 ) {
					continue;
				}

				// Append ledger row.
				$allocs = $target_item->get_meta( $meta_key_allocs, true );
				if ( ! is_array( $allocs ) ) {
					$allocs = array();
				}
				$allocs[] = array(
					'po_id'         => $po_id,
					'po_number'     => $po_number,
					'qty_allocated' => (int) $allocate_now,
					'eta'           => $eta_to_store,
					'status'        => 'reserved',
					'allocated_at'  => $today_dt,
				);
				$target_item->update_meta_data( $meta_key_allocs, $allocs );
				$target_item->save();

				// Note: private order note.
				$product     = $target_item->get_product();
				$sku         = $product instanceof \WC_Product ? $product->get_sku() : '';
				$line_name   = $target_item->get_name();
				$eta_display = $eta_to_store ? $eta_to_store : ( $po_eta_header ?: '-' );
				$note = sprintf(
					/* translators: 1: qty, 2: item name, 3: SKU, 4: PO number, 5: ETA */
					__( 'Allocated %1$dx %2$s%3$s from PO #%4$s (ETA %5$s).', 'lpr-backorder-allocator' ),
					(int) $allocate_now,
					$line_name,
					$sku ? ' [' . $sku . ']' : '',
					$po_number ? $po_number : (string) $po_id,
					$eta_display
				);
				$order->add_order_note( $note, false, true );

				$affected_orders[ (int) $order->get_id() ] = true;

				$remaining_for_line -= $allocate_now;
				$allocated_total    += $allocate_now;
			}

			return $allocated_total;
		}

		/**
		 * Build a FIFO queue of order items needing allocation for a given product/variation.
		 * Sorted by: paid date ASC (fallback created), then created ASC, then order ID ASC.
		 * Uses server-side pagination and stops once the sum of need >= required_total or no more orders.
		 *
		 * @param int $target_id
		 * @param int $required_total
		 * @return array[] Each item: [order_id, item_id, need, paid_ts, created_ts]
		 */
		protected static function build_fifo_queue( int $target_id, int $required_total ): array {
			$settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
			$statuses = array();
			foreach ( (array) $settings['order_statuses'] as $st ) {
				$statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
			}

			$queue = array();
			$page  = 1;
			$limit = 50;
			$total_need_collected = 0;

			do {
				$args = array(
					'status'  => $statuses,
					'limit'   => $limit,
					'page'    => $page,
					'orderby' => 'date', // created date ASC. We'll re-sort by paid date later.
					'order'   => 'ASC',
					'return'  => 'ids',
					'type'    => 'shop_order',
				);
				$order_ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
				if ( empty( $order_ids ) ) {
					break;
				}

				foreach ( $order_ids as $oid ) {
					if ( $total_need_collected >= $required_total ) {
						break 2; // enough candidates gathered
					}
					$order = wc_get_order( $oid );
					if ( ! ( $order instanceof \WC_Order ) ) {
						continue;
					}
					$paid    = $order->get_date_paid();
					$created = $order->get_date_created();
					$paid_ts = $paid ? (int) $paid->getTimestamp() : null;
					$created_ts = $created ? (int) $created->getTimestamp() : 0;

					foreach ( $order->get_items( 'line_item' ) as $item ) {
						if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
							continue;
						}
						$itm_vid = (int) $item->get_variation_id();
						$itm_pid = (int) $item->get_product_id();
						$match   = ( $itm_vid > 0 ) ? ( $itm_vid === $target_id ) : ( $itm_pid === $target_id );
						if ( ! $match ) {
							continue;
						}
						if ( class_exists( __NAMESPACE__ . '\Backorder' ) && ! Backorder::needs_allocation( $item ) ) {
							continue;
						}
						$need = lpr_allocator_calc_backorder_need( $item );
						if ( $need <= 0 ) {
							continue;
						}

						$queue[] = array(
							'order_id'   => (int) $oid,
							'item_id'    => (int) $item->get_id(),
							'need'       => (int) $need,
							'paid_ts'    => $paid_ts,
							'created_ts' => $created_ts,
						);
						$total_need_collected += (int) $need;
						if ( $total_need_collected >= $required_total ) {
							break 2;
						}
					}
				}

				$page++;
			} while ( true );

			if ( empty( $queue ) ) {
				return array();
			}

			usort(
				$queue,
				static function ( $a, $b ) {
					$ap = isset( $a['paid_ts'] ) && null !== $a['paid_ts'] ? (int) $a['paid_ts'] : (int) $a['created_ts'];
					$bp = isset( $b['paid_ts'] ) && null !== $b['paid_ts'] ? (int) $b['paid_ts'] : (int) $b['created_ts'];
					if ( $ap !== $bp ) {
						return $ap <=> $bp;
					}
					if ( (int) $a['created_ts'] !== (int) $b['created_ts'] ) {
						return (int) $a['created_ts'] <=> (int) $b['created_ts'];
					}
					return (int) $a['order_id'] <=> (int) $b['order_id'];
				}
			);

			return $queue;
		}
	}
	PO_FIFO_Allocator::init();
}

if ( ! class_exists( __NAMESPACE__ . '\PO_Allocate_Button_UI' ) ) {
	/**
	 * Adds an "Allocate" button to the Supplier PO edit screen (Publish box) and admin notices.
	 */
	class PO_Allocate_Button_UI {

		public static function init(): void {
			add_action( 'post_submitbox_misc_actions', array( __CLASS__, 'render_button' ) );
			add_action( 'admin_notices', array( __CLASS__, 'maybe_notice' ) );
		}

		/**
		 * Render button inside the submit box on the Supplier PO edit screen.
		 */
		public static function render_button(): void {
			global $post;
			if ( ! ( $post instanceof \WP_Post ) ) {
				return;
			}
			if ( ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) !== $post->post_type ) {
				return;
			}
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}

			$nonce  = wp_create_nonce( 'lpr_allocate_po_' . $post->ID );
			$url    = add_query_arg(
				array(
					'action'   => 'lpr_allocate_po',
					'po_id'    => (int) $post->ID,
					'_wpnonce' => $nonce,
				),
				admin_url( 'admin-post.php' )
			);

			// Small helper text and primary button.
			echo '<div class="misc-pub-section lpr-alloc">';
			echo '<a href="' . esc_url( $url ) . '" class="button button-primary">' . esc_html__( 'Allocate', 'lpr-backorder-allocator' ) . '</a>';
			echo '<span style="margin-left:8px;opacity:.8;">' . esc_html__( 'Assigns PO quantities to backordered orders (FIFO). No stock changes.', 'lpr-backorder-allocator' ) . '</span>';
			echo '</div>';
		}

		/**
		 * Show status notice after allocation trigger.
		 */
		public static function maybe_notice(): void {
			if ( empty( $_GET['lpr_alloc'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				return;
			}
			$state = sanitize_key( wp_unslash( $_GET['lpr_alloc'] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			if ( 'queued' === $state ) {
				echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'PO allocation queued. It will process shortly.', 'lpr-backorder-allocator' ) . '</p></div>';
			} elseif ( 'done' === $state ) {
				echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'PO allocation completed.', 'lpr-backorder-allocator' ) . '</p></div>';
			}
		}
	}
	PO_Allocate_Button_UI::init();
}

/* SELF-CHECK:
- Added PO_FIFO_Allocator (new class) with:
  - admin_post handler `lpr_allocate_po` (nonce + manage_woocommerce required).
  - Async worker via Action Scheduler (`lpr_allocator_allocate_po`) with fallback to inline if AS unavailable.
  - FIFO allocation per PO line: builds queue of backordered items (statuses from settings) sorted by paid date ASC (fallback created), then created ASC, then order ID ASC.
  - Allocates up to (qty_ordered - qty_allocated) per PO line; appends ledger rows to order item meta `lpr_allocations`; increments line `qty_allocated`; no stock writes.
  - Adds private order notes and batches ETA recompute via ETA::update_line_eta() for affected orders.
  - Uses wc_get_orders with pagination and returns IDs (no wildcard meta_query). Per-SKU transient lock to avoid contention.
- Added PO_Allocate_Button_UI (new class) to render "Allocate" button on PO edit and show admin notices.
- New helper function lpr_allocator_calc_backorder_need() (guarded) to compute remaining needed qty per item using Backordered meta or on_backorder fallback minus active allocations.
- All declarations are new & guarded; used Woo CRUD only; respects admin/cron-only early return; frontend remains untouched.
*/
/**
namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() ) {
	return;
}

/**
 * Helper: compute the "desired" backordered quantity for a line item.
 * Mirrors the logic used by lpr_allocator_calc_backorder_need(), but without subtracting allocations.
 */
if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_desired' ) ) {
	function lpr_allocator_calc_backorder_desired( \WC_Order_Item_Product $item ): int {
		if ( ! $item instanceof \WC_Order_Item_Product ) {
			return 0;
		}
		$qty     = max( 0, (int) $item->get_quantity() );
		$product = $item->get_product();
		if ( ! ( $product instanceof \WC_Product ) ) {
			return 0;
		}

		$desired = 0;
		foreach ( array( 'Backordered', '_backordered', 'backordered' ) as $k ) {
			$v = $item->get_meta( $k, true );
			if ( '' !== $v && null !== $v ) {
				$desired = max( $desired, (int) $v );
			}
		}
		if ( 0 === $desired && method_exists( $product, 'is_on_backorder' ) && $product->is_on_backorder( $qty ) ) {
			$desired = $qty; // fallback when Woo says the line is on backorder
		}

		// Safety clamp to the line quantity.
		return min( $desired, $qty );
	}
}

/**
 * Helper: sum of active (non-released) allocations for a line item.
 */
if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_get_item_allocated_active' ) ) {
	function lpr_allocator_get_item_allocated_active( \WC_Order_Item_Product $item ): int {
		if ( ! $item instanceof \WC_Order_Item_Product ) {
			return 0;
		}
		$key   = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
		$alloc = $item->get_meta( $key, true );
		$sum   = 0;
		if ( is_array( $alloc ) ) {
			foreach ( $alloc as $row ) {
				$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
				if ( 'released' === $status ) {
					continue;
				}
				$sum += isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
			}
		}
		return max( 0, $sum );
	}
}

/**
 * Helper: get or create a "Quick PO Draft" for the current user and optionally seed header meta.
 */
if ( ! function_exists( __NAMESPACE__ . '\lpr_allocator_get_or_create_quick_po_for_user' ) ) {
	function lpr_allocator_get_or_create_quick_po_for_user( string $supplier = '', string $eta_ymd = '', string $po_number = '' ): int {
		$user_id = get_current_user_id();
		if ( $user_id <= 0 ) {
			return 0;
		}
		$meta_key = 'lpr_quick_po_draft_id';
		$po_id    = (int) get_user_meta( $user_id, $meta_key, true );

		$valid = false;
		if ( $po_id > 0 ) {
			$post = get_post( $po_id );
			if ( $post instanceof \WP_Post && $post->post_type === ( defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po' ) && 'trash' !== $post->post_status ) {
				$valid = true;
			}
		}

		if ( ! $valid ) {
			$title = sprintf(
				/* translators: 1: user display name, 2: date time */
				__( 'Quick PO Draft – %1$s – %2$s', 'lpr-backorder-allocator' ),
				wp_get_current_user()->display_name ?: 'User',
				wp_date( 'Y-m-d H:i' )
			);
			$po_id = wp_insert_post(
				array(
					'post_type'   => defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po',
					'post_status' => defined( __NAMESPACE__ . '\PO_STATUS_OPEN' ) ? PO_STATUS_OPEN : 'draft',
					'post_title'  => $title,
				),
				true
			);
			if ( is_wp_error( $po_id ) ) {
				return 0;
			}
			update_user_meta( $user_id, $meta_key, (int) $po_id );
		}

		// Seed header fields if provided (non-empty).
		if ( $po_id > 0 ) {
			if ( '' !== $supplier ) {
				update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_SUPPLIER_NAME' ) ? PO_META_SUPPLIER_NAME : '_lpr_supplier_name', sanitize_text_field( $supplier ) );
			}
			if ( '' !== $po_number ) {
				update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_PO_NUMBER' ) ? PO_META_PO_NUMBER : '_lpr_po_number', sanitize_text_field( $po_number ) );
			}
			if ( '' !== $eta_ymd ) {
				update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date', lpr_allocator_sanitize_ymd( $eta_ymd ) );
			}
			// Ensure lines array exists.
			$lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
			if ( ! is_array( $lines ) ) {
				update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', array() );
			}
		}

		return (int) $po_id;
	}
}

/**
 * Builds a cached "backordered products" index from orders (async-capable via Action Scheduler).
 */
if ( ! class_exists( __NAMESPACE__ . '\Backorder_Indexer' ) ) {
	class Backorder_Indexer {

		const OPT_KEY = 'lpr_allocator_backorder_index';
		const MAX_AGE = 600; // seconds

		public static function init(): void {
			add_action( 'admin_init', array( __CLASS__, 'ensure_index_option' ) );
			add_action( 'admin_post_lpr_build_backorder_index', array( __CLASS__, 'handle_build_index_request' ) );
			// Async worker (Action Scheduler).
			add_action( 'lpr_allocator_build_index', array( __CLASS__, 'build_and_store' ) );
		}

		public static function ensure_index_option(): void {
			if ( null === get_option( self::OPT_KEY, null ) ) {
				add_option( self::OPT_KEY, array( 'built_at' => 0, 'rows' => array() ), '', 'no' );
				// Kick off an initial async build if AS available, else do a lightweight inline build (first page only).
				if ( function_exists( 'as_enqueue_async_action' ) ) {
					as_enqueue_async_action( 'lpr_allocator_build_index', array(), 'lpr-allocator' );
				} else {
					// Inline quick build (best-effort).
					self::build_and_store( false );
				}
			}
		}

		public static function handle_build_index_request(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) );
			}
			$nonce = isset( $_GET['_wpnonce'] ) ? (string) $_GET['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			if ( ! wp_verify_nonce( $nonce, 'lpr_build_backorder_index' ) ) {
				wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
			}
			$redirect = isset( $_GET['redirect'] ) ? esc_url_raw( wp_unslash( $_GET['redirect'] ) ) : admin_url( 'admin.php?page=lpr-backordered-products' ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended

			$queued = false;
			if ( function_exists( 'as_enqueue_async_action' ) ) {
				as_enqueue_async_action( 'lpr_allocator_build_index', array(), 'lpr-allocator' );
				$queued = true;
			} elseif ( function_exists( 'as_schedule_single_action' ) ) {
				as_schedule_single_action( time(), 'lpr_allocator_build_index', array(), 'lpr-allocator' );
				$queued = true;
			} else {
				self::build_and_store( false );
			}

			wp_safe_redirect( add_query_arg( array( 'lpr_index' => $queued ? 'queued' : 'rebuilt' ), $redirect ) );
			exit;
		}

		/**
		 * Returns the index array: ['built_at'=>timestamp, 'rows'=>[ id => [desired_total, allocated_total, need_total, count] ] ]
		 *
		 * @param bool $allow_stale When false, will attempt to queue a rebuild if stale.
		 */
		public static function get_index( bool $allow_stale = true ): array {
			$idx = get_option( self::OPT_KEY, array( 'built_at' => 0, 'rows' => array() ) );
			if ( ! is_array( $idx ) || ! isset( $idx['rows'] ) ) {
				$idx = array( 'built_at' => 0, 'rows' => array() );
			}
			// If stale and allowed, queue a refresh (non-blocking).
			if ( ! $allow_stale ) {
				$stale = ( time() - (int) $idx['built_at'] ) > self::MAX_AGE;
				if ( $stale && function_exists( 'as_enqueue_async_action' ) ) {
					as_enqueue_async_action( 'lpr_allocator_build_index', array(), 'lpr-allocator' );
				}
			}
			return $idx;
		}

		/**
		 * Build full snapshot and store in option.
		 *
		 * @param bool $paginate_early_break If true, performs a shallow build (useful for inline warmup without timeouts).
		 */
		public static function build_and_store( bool $paginate_early_break = false ): void {
			$snapshot = self::build_snapshot( $paginate_early_break );
			$existing = get_option( self::OPT_KEY, null );
			if ( null === $existing ) {
				add_option( self::OPT_KEY, $snapshot, '', 'no' );
			} else {
				update_option( self::OPT_KEY, $snapshot, false );
			}
		}

		/**
		 * Build the backorder snapshot by scanning orders in configured statuses.
		 *
		 * @return array
		 */
		protected static function build_snapshot( bool $paginate_early_break = false ): array {
			$settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
			$statuses = array();
			foreach ( (array) $settings['order_statuses'] as $st ) {
				$statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
			}

			$rows  = array(); // id => ['desired_total'=>int, 'allocated_total'=>int, 'need_total'=>int, 'items'=>int]
			$page  = 1;
			$limit = 50;
			$scanned_pages = 0;

			do {
				$args      = array(
					'status'  => $statuses,
					'limit'   => $limit,
					'page'    => $page,
					'orderby' => 'date',
					'order'   => 'ASC',
					'return'  => 'ids',
					'type'    => 'shop_order',
				);
				$order_ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
				if ( empty( $order_ids ) ) {
					break;
				}

				foreach ( $order_ids as $oid ) {
					$order = wc_get_order( $oid );
					if ( ! ( $order instanceof \WC_Order ) ) {
						continue;
					}
					foreach ( $order->get_items( 'line_item' ) as $item ) {
						if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
							continue;
						}
						// Treat variation as primary ID when present.
						$target_id = (int) $item->get_variation_id();
						if ( $target_id <= 0 ) {
							$target_id = (int) $item->get_product_id();
						}
						if ( $target_id <= 0 || ! lpr_allocator_product_exists( $target_id ) ) {
							continue;
						}

						$desired   = lpr_allocator_calc_backorder_desired( $item );
						if ( $desired <= 0 ) {
							continue; // not a backordered line
						}
						$allocated = lpr_allocator_get_item_allocated_active( $item );

						if ( ! isset( $rows[ $target_id ] ) ) {
							$rows[ $target_id ] = array(
								'desired_total'  => 0,
								'allocated_total'=> 0,
								'need_total'     => 0,
								'items'          => 0,
							);
						}
						$rows[ $target_id ]['desired_total']   += (int) $desired;
						$rows[ $target_id ]['allocated_total'] += (int) $allocated;
						$rows[ $target_id ]['items']           += 1;
					}
				}

				$page++;
				$scanned_pages++;
				if ( $paginate_early_break && $scanned_pages >= 2 ) { // shallow build: scan just first ~100 orders
					break;
				}
			} while ( true );

			// Finalize needs and clamp.
			foreach ( $rows as $pid => &$agg ) {
				$agg['desired_total']   = max( 0, (int) $agg['desired_total'] );
				$agg['allocated_total'] = max( 0, (int) $agg['allocated_total'] );
				$agg['need_total']      = max( 0, (int) ( $agg['desired_total'] - $agg['allocated_total'] ) );
			}
			unset( $agg );

			return array(
				'built_at' => time(),
				'rows'     => $rows,
			);
		}
	}
	Backorder_Indexer::init();
}

/**
 * Admin page: "Backordered Products" with quick add-to-PO actions.
 */
if ( ! class_exists( __NAMESPACE__ . '\Backordered_Products_Page' ) ) {
	class Backordered_Products_Page {

		public static function init(): void {
			add_action( 'admin_menu', array( __CLASS__, 'register_page' ) );
		}

		public static function register_page(): void {
			add_submenu_page(
				'woocommerce',
				__( 'Backordered Products', 'lpr-backorder-allocator' ),
				__( 'Backordered Products', 'lpr-backorder-allocator' ),
				'manage_woocommerce',
				'lpr-backordered-products',
				array( __CLASS__, 'render' )
			);
		}

		protected static function filter_rows( array $rows, string $view ): array {
			$out = array();
			foreach ( $rows as $pid => $agg ) {
				$desired = isset( $agg['desired_total'] ) ? (int) $agg['desired_total'] : 0;
				$need    = isset( $agg['need_total'] ) ? (int) $agg['need_total'] : 0;
				if ( 'unallocated' === $view ) {
					if ( $need > 0 ) {
						$out[ $pid ] = $agg;
					}
				} elseif ( 'allocated' === $view ) {
					if ( $desired > 0 && 0 === $need ) {
						$out[ $pid ] = $agg;
					}
				} else { // 'all'
					if ( $desired > 0 ) {
						$out[ $pid ] = $agg;
					}
				}
			}
			return $out;
		}

		public static function render(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}

			$view = isset( $_GET['view'] ) ? sanitize_key( wp_unslash( $_GET['view'] ) ) : 'unallocated'; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			if ( ! in_array( $view, array( 'unallocated', 'all', 'allocated' ), true ) ) {
				$view = 'unallocated';
			}

			$idx       = class_exists( __NAMESPACE__ . '\Backorder_Indexer' ) ? Backorder_Indexer::get_index( false ) : array( 'built_at' => 0, 'rows' => array() );
			$built_ts  = isset( $idx['built_at'] ) ? (int) $idx['built_at'] : 0;
			$rows_all  = isset( $idx['rows'] ) && is_array( $idx['rows'] ) ? $idx['rows'] : array();
			$rows_view = self::filter_rows( $rows_all, $view );

			// Sort: need desc, then desired desc.
			uasort(
				$rows_view,
				static function ( $a, $b ) {
					$an = (int) ( $a['need_total'] ?? 0 );
					$bn = (int) ( $b['need_total'] ?? 0 );
					if ( $an !== $bn ) {
						return ( $bn <=> $an );
					}
					$ad = (int) ( $a['desired_total'] ?? 0 );
					$bd = (int) ( $b['desired_total'] ?? 0 );
					return ( $bd <=> $ad );
				}
			);

			// Pagination (server-side on snapshot).
			$page     = isset( $_GET['paged'] ) ? max( 1, (int) $_GET['paged'] ) : 1; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			$per_page = 25;
			$total    = count( $rows_view );
			$pages    = max( 1, (int) ceil( $total / $per_page ) );
			$offset   = ( $page - 1 ) * $per_page;
			$subset   = array_slice( $rows_view, $offset, $per_page, true );

			$rebuild_url = wp_nonce_url(
				add_query_arg(
					array(
						'action'   => 'lpr_build_backorder_index',
						'redirect' => rawurlencode( admin_url( 'admin.php?page=lpr-backordered-products&view=' . $view . '&paged=' . $page ) ),
					),
					admin_url( 'admin-post.php' )
				),
				'lpr_build_backorder_index'
			);

			// Notices.
			if ( isset( $_GET['lpr_index'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				$state = sanitize_key( wp_unslash( $_GET['lpr_index'] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				if ( 'queued' === $state ) {
					echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'Backorder index rebuild has been queued.', 'lpr-backorder-allocator' ) . '</p></div>';
				} elseif ( 'rebuilt' === $state ) {
					echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'Backorder index rebuilt.', 'lpr-backorder-allocator' ) . '</p></div>';
				}
			}
			if ( isset( $_GET['lpr_added'] ) && isset( $_GET['po_id'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				$po_id = absint( $_GET['po_id'] ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				$link  = $po_id ? get_edit_post_link( $po_id, 'url' ) : '';
				$msg   = $link
					? sprintf( __( 'Added to PO draft. %sEdit PO%s.', 'lpr-backorder-allocator' ), '<a href="' . esc_url( $link ) . '">', '</a>' )
					: __( 'Added to PO draft.', 'lpr-backorder-allocator' );
				echo '<div class="notice notice-success is-dismissible"><p>' . wp_kses_post( $msg ) . '</p></div>';
			}

			// Controls.
			?>
			<div class="wrap">
				<h1><?php echo esc_html__( 'Backordered Products', 'lpr-backorder-allocator' ); ?></h1>
				<div style="margin:10px 0; display:flex; gap:12px; align-items:center;">
					<form method="get" action="">
						<input type="hidden" name="page" value="lpr-backordered-products" />
						<label for="lpr-view"><strong><?php echo esc_html__( 'View', 'lpr-backorder-allocator' ); ?>:</strong></label>
						<select id="lpr-view" name="view" onchange="this.form.submit()">
							<option value="unallocated" <?php selected( $view, 'unallocated' ); ?>><?php echo esc_html__( 'Not fully allocated', 'lpr-backorder-allocator' ); ?></option>
							<option value="all" <?php selected( $view, 'all' ); ?>><?php echo esc_html__( 'All backordered (incl. fully allocated)', 'lpr-backorder-allocator' ); ?></option>
							<option value="allocated" <?php selected( $view, 'allocated' ); ?>><?php echo esc_html__( 'Fully allocated', 'lpr-backorder-allocator' ); ?></option>
						</select>
						<noscript><button class="button"><?php esc_html_e( 'Apply', 'lpr-backorder-allocator' ); ?></button></noscript>
					</form>

					<a class="button button-secondary" href="<?php echo esc_url( $rebuild_url ); ?>">
						<?php echo esc_html__( 'Rebuild Snapshot', 'lpr-backorder-allocator' ); ?>
					</a>

					<span style="opacity:.8;">
						<?php
						echo esc_html(
							sprintf(
								/* translators: %s: datetime */
								__( 'Last built: %s', 'lpr-backorder-allocator' ),
								$built_ts ? wp_date( 'Y-m-d H:i:s', $built_ts ) : __( 'never', 'lpr-backorder-allocator' )
							)
						);
						?>
					</span>
				</div>

				<style>
					.lpr-backorders-table { width:100%; border-collapse: collapse; }
					.lpr-backorders-table th, .lpr-backorders-table td { padding:8px; border-bottom:1px solid #e5e5e5; text-align:left; vertical-align:top; }
					.lpr-backorders-table th.num, .lpr-backorders-table td.num { text-align:right; white-space:nowrap; }
					.lpr-quick-form { display:flex; gap:6px; flex-wrap:wrap; align-items:center; }
					.lpr-quick-form input[type="number"] { width:90px; }
					.lpr-quick-form input[type="text"], .lpr-quick-form input[type="date"] { width:140px; }
					.tablenav-pages { margin-top: 12px; }
				</style>

				<table class="widefat striped lpr-backorders-table">
					<thead>
						<tr>
							<th><?php echo esc_html__( 'Product / Variation', 'lpr-backorder-allocator' ); ?></th>
							<th class="num"><?php echo esc_html__( 'Backordered', 'lpr-backorder-allocator' ); ?></th>
							<th class="num"><?php echo esc_html__( 'Allocated', 'lpr-backorder-allocator' ); ?></th>
							<th class="num"><?php echo esc_html__( 'Required to Allocate', 'lpr-backorder-allocator' ); ?></th>
							<th><?php echo esc_html__( 'Quick add to Supplier PO draft', 'lpr-backorder-allocator' ); ?></th>
						</tr>
					</thead>
					<tbody>
						<?php if ( empty( $subset ) ) : ?>
							<tr><td colspan="5"><?php echo esc_html__( 'No results for this view.', 'lpr-backorder-allocator' ); ?></td></tr>
						<?php else : ?>
							<?php foreach ( $subset as $pid => $agg ) :
								$desired = (int) ( $agg['desired_total'] ?? 0 );
								$alloc   = (int) ( $agg['allocated_total'] ?? 0 );
                                // Clamp allocated not to exceed desired for display sanity.
								if ( $alloc > $desired ) { $alloc = $desired; }
								$need    = max( 0, (int) ( $agg['need_total'] ?? ( $desired - $alloc ) ) );
								$label   = function_exists( __NAMESPACE__ . '\lpr_allocator_product_option_label' ) ? lpr_allocator_product_option_label( (int) $pid ) : ( '#' . (int) $pid );
								$edit    = get_edit_post_link( (int) $pid, 'url' );
								?>
								<tr>
									<td>
										<?php if ( $edit ) : ?>
											<a href="<?php echo esc_url( $edit ); ?>"><?php echo esc_html( $label ); ?></a>
										<?php else : ?>
											<?php echo esc_html( $label ); ?>
										<?php endif; ?>
									</td>
									<td class="num"><?php echo esc_html( (string) $desired ); ?></td>
									<td class="num"><?php echo esc_html( (string) $alloc ); ?></td>
									<td class="num"><strong><?php echo esc_html( (string) $need ); ?></strong></td>
									<td>
										<form class="lpr-quick-form" method="post" action="<?php echo esc_url( admin_url( 'admin-post.php' ) ); ?>">
											<input type="hidden" name="action" value="lpr_quick_add_to_po" />
											<?php wp_nonce_field( 'lpr_quick_add_to_po', 'lpr_quick_nonce' ); ?>
											<input type="hidden" name="product_id" value="<?php echo esc_attr( (string) $pid ); ?>" />
											<input type="hidden" name="redirect" value="<?php echo esc_attr( admin_url( 'admin.php?page=lpr-backordered-products&view=' . $view . '&paged=' . $page ) ); ?>" />
											<label>
												<?php echo esc_html__( 'Qty', 'lpr-backorder-allocator' ); ?>
												<input type="number" min="1" step="1" name="qty" value="<?php echo esc_attr( (string) max( 1, $need ) ); ?>" />
											</label>
											<label>
												<?php echo esc_html__( 'Supplier', 'lpr-backorder-allocator' ); ?>
												<input type="text" name="supplier_name" />
											</label>
											<label>
												<?php echo esc_html__( 'ETA (Y-m-d)', 'lpr-backorder-allocator' ); ?>
												<input type="date" name="eta_ymd" />
											</label>
											<button type="submit" class="button button-secondary"><?php echo esc_html__( 'Add to PO Draft', 'lpr-backorder-allocator' ); ?></button>
										</form>
									</td>
								</tr>
							<?php endforeach; ?>
						<?php endif; ?>
					</tbody>
				</table>

				<?php if ( $pages > 1 ) : ?>
					<div class="tablenav-pages">
						<span class="displaying-num"><?php echo esc_html( sprintf( _n( '%s item', '%s items', $total, 'lpr-backorder-allocator' ), number_format_i18n( $total ) ) ); ?></span>
						<span class="pagination-links">
							<?php
							$base_url = admin_url( 'admin.php?page=lpr-backordered-products&view=' . $view . '&paged=%#%' );
							echo wp_kses_post(
								paginate_links(
									array(
										'base'      => $base_url,
										'format'    => '',
										'current'   => $page,
										'total'     => $pages,
										'prev_text' => __( '&laquo;', 'lpr-backorder-allocator' ),
										'next_text' => __( '&raquo;', 'lpr-backorder-allocator' ),
									)
								)
							);
							?>
						</span>
					</div>
				<?php endif; ?>
			</div>
			<?php
		}
	}
	Backordered_Products_Page::init();
}

/**
 * Admin-post handler: quick add a product to the current user's PO draft.
 */
if ( ! class_exists( __NAMESPACE__ . '\Quick_PO_Add_Handler' ) ) {
	class Quick_PO_Add_Handler {

		public static function init(): void {
			add_action( 'admin_post_lpr_quick_add_to_po', array( __CLASS__, 'handle' ) );
		}

		public static function handle(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) );
			}
			if ( ! isset( $_POST['lpr_quick_nonce'] ) || ! wp_verify_nonce( sanitize_text_field( wp_unslash( $_POST['lpr_quick_nonce'] ) ), 'lpr_quick_add_to_po' ) ) {
				wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
			}

			$product_id = isset( $_POST['product_id'] ) ? absint( $_POST['product_id'] ) : 0;
			$qty        = isset( $_POST['qty'] ) ? max( 1, (int) $_POST['qty'] ) : 1;
			$supplier   = isset( $_POST['supplier_name'] ) ? sanitize_text_field( wp_unslash( $_POST['supplier_name'] ) ) : '';
			$eta_raw    = isset( $_POST['eta_ymd'] ) ? (string) wp_unslash( $_POST['eta_ymd'] ) : '';
			$eta_ymd    = lpr_allocator_sanitize_ymd( $eta_raw );
			$redirect   = isset( $_POST['redirect'] ) ? esc_url_raw( wp_unslash( $_POST['redirect'] ) ) : admin_url( 'admin.php?page=lpr-backordered-products' );

			if ( $product_id <= 0 || ! lpr_allocator_product_exists( $product_id ) ) {
				wp_safe_redirect( add_query_arg( array( 'lpr_added' => '0' ), $redirect ) );
				exit;
			}

			$po_id = lpr_allocator_get_or_create_quick_po_for_user( $supplier, $eta_ymd, '' );
			if ( $po_id <= 0 ) {
				wp_safe_redirect( add_query_arg( array( 'lpr_added' => '0' ), $redirect ) );
				exit;
			}

			$lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
			if ( ! is_array( $lines ) ) {
				$lines = array();
			}

			// Determine whether the product is a variation.
			$is_variation = false;
			if ( function_exists( 'wc_get_product' ) ) {
				$p = wc_get_product( $product_id );
				$is_variation = ( $p instanceof \WC_Product ) ? $p->is_type( 'variation' ) : false;
			}

			// Try to merge with an existing line of the same product/variation.
			$merged = false;
			foreach ( $lines as &$line ) {
				$line_vid = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
				$line_pid = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;

				if ( $is_variation ) {
					if ( $line_vid === $product_id ) {
						$line['qty_ordered']   = max( 0, (int) ( $line['qty_ordered'] ?? 0 ) ) + $qty;
						$line['qty_allocated'] = max( 0, (int) ( $line['qty_allocated'] ?? 0 ) );
						if ( $eta_ymd ) {
							$line['eta_override'] = $eta_ymd;
						}
						$line['qty_received']  = max( 0, (int) ( $line['qty_received'] ?? 0 ) );
						$merged = true;
						break;
					}
				} else {
					if ( $line_vid === 0 && $line_pid === $product_id ) {
						$line['qty_ordered']   = max( 0, (int) ( $line['qty_ordered'] ?? 0 ) ) + $qty;
						$line['qty_allocated'] = max( 0, (int) ( $line['qty_allocated'] ?? 0 ) );
						if ( $eta_ymd ) {
							$line['eta_override'] = $eta_ymd;
						}
						$line['qty_received']  = max( 0, (int) ( $line['qty_received'] ?? 0 ) );
						$merged = true;
						break;
					}
				}
			}
			unset( $line );

			if ( ! $merged ) {
				$new = array(
					'qty_ordered'   => (int) $qty,
					'qty_allocated' => 0,
					'eta_override'  => $eta_ymd,
					'qty_received'  => 0,
				);
				if ( $is_variation ) {
					$new['variation_id'] = (int) $product_id;
				} else {
					$new['product_id'] = (int) $product_id;
				}
				$lines[] = $new;
			}

			update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', $lines );

			wp_safe_redirect( add_query_arg( array( 'lpr_added' => '1', 'po_id' => (int) $po_id ), $redirect ) );
			exit;
		}
	}
	Quick_PO_Add_Handler::init();
}

/* SELF-CHECK:
- Added: helper functions lpr_allocator_calc_backorder_desired(), lpr_allocator_get_item_allocated_active(), lpr_allocator_get_or_create_quick_po_for_user() — all guarded; no re-declarations.
- Added classes (guarded): Backorder_Indexer (async Action Scheduler snapshot builder, option autoload=no), Backordered_Products_Page (admin submenu + report UI + dropdown filter showing unallocated/all/allocated), Quick_PO_Add_Handler (admin-post) to quick-add lines to a Supplier PO draft.
- Hooks: admin_init (ensure index), admin_menu (page), admin_post (build index + quick add), AS action 'lpr_allocator_build_index'.
- Admin/cron-only load ensured at top; no frontend hooks added.
- CRUD/HPOS APIs only: wc_get_orders / wc_get_order / WC_Order_Item_Product / wc_get_product; PO uses get_post_meta/update_post_meta; no wildcard meta_query; server-side pagination while scanning orders; snapshot cached in option; no stock writes.
- Options saved with autoload=no (lpr_allocator_backorder_index). User meta used for per-user quick draft pointer.
- Included nonces/capability checks and sanitized inputs; Supplier PO lines appended/merged without touching stock.
- The page lists backordered products not fully allocated by default, shows "Backordered", "Allocated", and "Required to Allocate" columns; includes a dropdown to also see all backordered (including fully allocated) or only fully allocated; each row has a "Quick add to Supplier PO draft" mini-form.
*/
namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() ) {
	return;
}

/**
 * VIP Prioritization settings (separate option, autoload=no).
 */
if ( ! defined( __NAMESPACE__ . '\VIP_SETTINGS_OPTION' ) ) {
	define( __NAMESPACE__ . '\VIP_SETTINGS_OPTION', 'lpr_allocator_vip_settings' );
}

if ( ! class_exists( __NAMESPACE__ . '\VIP_Settings' ) ) {
	class VIP_Settings {
		public static function key(): string {
			return VIP_SETTINGS_OPTION;
		}
		public static function defaults(): array {
			return array(
				'enabled'               => true,
				'notify_prioritized'    => true,
				'notify_donor'          => true,
				'subject_prioritized'   => __( 'We prioritized your order', 'lpr-backorder-allocator' ),
				'subject_donor'         => __( 'Update: your allocation has changed', 'lpr-backorder-allocator' ),
			);
		}
		public static function get(): array {
			$stored = get_option( self::key(), array() );
			if ( ! is_array( $stored ) ) {
				$stored = array();
			}
			return array_replace( self::defaults(), $stored );
		}
		public static function update( array $raw ): bool {
			$san = self::sanitize( $raw );
			$exists = get_option( self::key(), null );
			if ( null === $exists ) {
				return add_option( self::key(), $san, '', 'no' );
			}
			return update_option( self::key(), $san, false );
		}
		public static function sanitize( array $raw ): array {
			return array(
				'enabled'             => ! empty( $raw['enabled'] ),
				'notify_prioritized'  => ! empty( $raw['notify_prioritized'] ),
				'notify_donor'        => ! empty( $raw['notify_donor'] ),
				'subject_prioritized' => isset( $raw['subject_prioritized'] ) ? sanitize_text_field( $raw['subject_prioritized'] ) : self::defaults()['subject_prioritized'],
				'subject_donor'       => isset( $raw['subject_donor'] ) ? sanitize_text_field( $raw['subject_donor'] ) : self::defaults()['subject_donor'],
			);
		}
	}
}

/**
 * Append a small "VIP Prioritization" section to our existing Woo tab.
 */
if ( ! class_exists( __NAMESPACE__ . '\Admin_VIP_Settings_Section' ) ) {
	class Admin_VIP_Settings_Section {
		public static function init(): void {
			add_action( 'woocommerce_settings_tabs_lpr_backorders', array( __CLASS__, 'render' ), 99 );
			add_action( 'woocommerce_update_options_lpr_backorders', array( __CLASS__, 'save' ), 99 );
			// Ensure option exists (autoload=no).
			add_action( 'admin_init', array( __CLASS__, 'ensure_option' ) );
		}
		public static function ensure_option(): void {
			if ( null === get_option( VIP_Settings::key(), null ) ) {
				add_option( VIP_Settings::key(), VIP_Settings::defaults(), '', 'no' );
			}
		}
		public static function render(): void {
			if ( ! current_user_can( 'edit_posts' ) ) {
				return;
			}
			$opt = VIP_Settings::get();
			?>
			<h2><?php echo esc_html__( 'VIP Prioritization', 'lpr-backorder-allocator' ); ?></h2>
			<p class="description"><?php echo esc_html__( 'Allow admins to move existing PO allocations from the oldest queued order to the current order. No stock is changed; only the allocation ledger is adjusted.', 'lpr-backorder-allocator' ); ?></p>
			<table class="form-table">
				<tr>
					<th scope="row"><?php echo esc_html__( 'Enable VIP feature', 'lpr-backorder-allocator' ); ?></th>
					<td>
						<label>
							<input type="checkbox" name="lpr_vip_enabled" value="1" <?php checked( $opt['enabled'], true ); ?> />
							<?php echo esc_html__( 'Enable the Prioritize/VIP button and processing', 'lpr-backorder-allocator' ); ?>
						</label>
					</td>
				</tr>
				<tr>
					<th scope="row"><?php echo esc_html__( 'Customer notifications', 'lpr-backorder-allocator' ); ?></th>
					<td>
						<label style="display:block;margin-bottom:6px;">
							<input type="checkbox" name="lpr_vip_notify_prioritized" value="1" <?php checked( $opt['notify_prioritized'], true ); ?> />
							<?php echo esc_html__( 'Email prioritized customer', 'lpr-backorder-allocator' ); ?>
						</label>
						<label style="display:block;">
							<input type="checkbox" name="lpr_vip_notify_donor" value="1" <?php checked( $opt['notify_donor'], true ); ?> />
							<?php echo esc_html__( 'Email donor (customer who lost allocation)', 'lpr-backorder-allocator' ); ?>
						</label>
					</td>
				</tr>
				<tr>
					<th scope="row"><?php echo esc_html__( 'Email subject (prioritized)', 'lpr-backorder-allocator' ); ?></th>
					<td><input type="text" class="regular-text" name="lpr_vip_subject_prioritized" value="<?php echo esc_attr( $opt['subject_prioritized'] ); ?>" /></td>
				</tr>
				<tr>
					<th scope="row"><?php echo esc_html__( 'Email subject (donor)', 'lpr-backorder-allocator' ); ?></th>
					<td><input type="text" class="regular-text" name="lpr_vip_subject_donor" value="<?php echo esc_attr( $opt['subject_donor'] ); ?>" /></td>
				</tr>
			</table>
			<?php
		}
		public static function save(): void {
			if ( ! current_user_can( 'edit_posts' ) ) {
				return;
			}
			if ( function_exists( 'check_admin_referer' ) ) {
				check_admin_referer( 'woocommerce-settings' );
			}
			$raw = array(
				'enabled'             => ! empty( $_POST['lpr_vip_enabled'] ),
				'notify_prioritized'  => ! empty( $_POST['lpr_vip_notify_prioritized'] ),
				'notify_donor'        => ! empty( $_POST['lpr_vip_notify_donor'] ),
				'subject_prioritized' => isset( $_POST['lpr_vip_subject_prioritized'] ) ? (string) wp_unslash( $_POST['lpr_vip_subject_prioritized'] ) : '',
				'subject_donor'       => isset( $_POST['lpr_vip_subject_donor'] ) ? (string) wp_unslash( $_POST['lpr_vip_subject_donor'] ) : '',
			);
			VIP_Settings::update( $raw );
		}
	}
	Admin_VIP_Settings_Section::init();
}

/**
 * UI: Add a "Prioritize (VIP)" meta box on order screens when eligible.
 */
if ( ! class_exists( __NAMESPACE__ . '\Order_Prioritize_UI' ) ) {
	class Order_Prioritize_UI {
		public static function init(): void {
			add_action( 'add_meta_boxes', array( __CLASS__, 'register_box' ), 30 );
			add_action( 'add_meta_boxes_shop_order', array( __CLASS__, 'register_box' ), 30 );
			add_action( 'add_meta_boxes_woocommerce_page_wc-orders', array( __CLASS__, 'register_box' ), 30 );
			add_action( 'admin_notices', array( __CLASS__, 'maybe_notice' ) );
		}
		public static function register_box(): void {
			if ( ! current_user_can( 'edit_posts' ) ) {
				return;
			}
			add_meta_box(
				'lpr_vip_prioritize',
				__( 'Prioritize (VIP)', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_box' ),
				'shop_order',
				'side',
				'high'
			);
			add_meta_box(
				'lpr_vip_prioritize',
				__( 'Prioritize (VIP)', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_box' ),
				'woocommerce_page_wc-orders',
				'side',
				'high'
			);
		}
		protected static function resolve_order_id( $context ): int {
			$order_id = 0;
			if ( $context instanceof \WP_Post ) {
				$order_id = (int) $context->ID;
			}
			if ( $order_id <= 0 && isset( $_GET['id'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				$order_id = absint( $_GET['id'] ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			}
			return $order_id;
		}
		protected static function order_has_need_and_others_allocated( \WC_Order $order ): bool {
			// If VIP feature disabled, no button.
			$vip = class_exists( __NAMESPACE__ . '\VIP_Settings' ) ? VIP_Settings::get() : array( 'enabled' => false );
			if ( empty( $vip['enabled'] ) ) {
				return false;
			}
			// Quick path: Use snapshot if present to detect "allocations exist on same products".
			$needs = array(); // product_id => need qty
			foreach ( $order->get_items( 'line_item' ) as $item ) {
				if ( ! ( $item instanceof \WC_Order_Item_Product ) ) {
					continue;
				}
				if ( class_exists( __NAMESPACE__ . '\Backorder' ) && ! Backorder::needs_allocation( $item ) ) {
					continue;
				}
				if ( function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_need' ) ) {
					$n = lpr_allocator_calc_backorder_need( $item );
				} else {
					$n = 0;
				}
				if ( $n > 0 ) {
					$pid = (int) ( $item->get_variation_id() ?: $item->get_product_id() );
					if ( $pid > 0 ) {
						$needs[ $pid ] = ( $needs[ $pid ] ?? 0 ) + $n;
					}
				}
			}
			if ( empty( $needs ) ) {
				return false;
			}
			// Check snapshot aggregated allocations across all orders.
			$index_ok = class_exists( __NAMESPACE__ . '\Backorder_Indexer' );
			if ( $index_ok ) {
				$idx = \LPR\Allocator\Backorder_Indexer::get_index( false );
				$rows = is_array( $idx['rows'] ?? null ) ? $idx['rows'] : array();
				foreach ( $needs as $pid => $need_qty ) {
					$row = $rows[ $pid ] ?? null;
					$alloc_total = (int) ( $row['allocated_total'] ?? 0 );
					if ( $need_qty > 0 && $alloc_total > 0 ) {
						return true;
					}
				}
			}
			// Fallback: light scan first N orders for any active allocations of same products.
			$settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
			$statuses = array();
			foreach ( (array) $settings['order_statuses'] as $st ) {
				$statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
			}
			$args = array(
				'status'  => $statuses,
				'limit'   => 50,
				'page'    => 1,
				'orderby' => 'date',
				'order'   => 'ASC',
				'return'  => 'ids',
				'type'    => 'shop_order',
			);
			$order_ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
			foreach ( $order_ids as $oid ) {
				if ( (int) $oid === (int) $order->get_id() ) { continue; }
				$o = wc_get_order( $oid );
				if ( ! ( $o instanceof \WC_Order ) ) { continue; }
				foreach ( $o->get_items( 'line_item' ) as $it ) {
					if ( ! ( $it instanceof \WC_Order_Item_Product ) ) { continue; }
					$pid = (int) ( $it->get_variation_id() ?: $it->get_product_id() );
					if ( $pid <= 0 || empty( $needs[ $pid ] ) ) { continue; }
					$key   = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
					$alloc = $it->get_meta( $key, true );
					if ( is_array( $alloc ) ) {
						foreach ( $alloc as $row ) {
							$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
							$q      = isset( $row['qty_allocated'] ) ? (int) $row['qty_allocated'] : 0;
							if ( 'released' !== $status && $q > 0 ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		}
		public static function render_box( $post_or_screen ): void {
			if ( ! function_exists( 'wc_get_order' ) ) {
				return;
			}
			$order_id = self::resolve_order_id( $post_or_screen );
			if ( $order_id <= 0 ) {
				echo '<p>' . esc_html__( 'Order not found.', 'lpr-backorder-allocator' ) . '</p>';
				return;
			}
			$order = wc_get_order( $order_id );
			if ( ! $order instanceof \WC_Order ) {
				echo '<p>' . esc_html__( 'Order not found.', 'lpr-backorder-allocator' ) . '</p>';
				return;
			}
			$eligible = self::order_has_need_and_others_allocated( $order );
			$nonce    = wp_create_nonce( 'lpr_prioritize_' . $order_id );
			$url      = add_query_arg(
				array(
					'action'   => 'lpr_prioritize_order',
					'order_id' => (int) $order_id,
					'_wpnonce' => $nonce,
				),
				admin_url( 'admin-post.php' )
			);

			echo '<div>';
			if ( $eligible ) {
				echo '<a href="' . esc_url( $url ) . '" class="button button-primary" style="width:100%;">' . esc_html__( 'Prioritize (VIP)', 'lpr-backorder-allocator' ) . '</a>';
				echo '<p class="description" style="margin-top:8px;">' . esc_html__( 'Move the earliest allocations from older orders to this order for any backordered items. No stock changes.', 'lpr-backorder-allocator' ) . '</p>';
			} else {
				echo '<p class="description">' . esc_html__( 'No eligible backordered items or no existing allocations to reassign.', 'lpr-backorder-allocator' ) . '</p>';
			}
			echo '</div>';
		}
		public static function maybe_notice(): void {
			if ( empty( $_GET['lpr_vip'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				return;
			}
			$state = sanitize_key( wp_unslash( $_GET['lpr_vip'] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			if ( 'queued' === $state ) {
				echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'VIP prioritization queued. It will process shortly.', 'lpr-backorder-allocator' ) . '</p></div>';
			} elseif ( 'done' === $state ) {
				echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'VIP prioritization completed.', 'lpr-backorder-allocator' ) . '</p></div>';
			} elseif ( 'none' === $state ) {
				echo '<div class="notice notice-warning is-dismissible"><p>' . esc_html__( 'No allocations could be reassigned.', 'lpr-backorder-allocator' ) . '</p></div>';
			}
		}
	}
	Order_Prioritize_UI::init();
}

/**
 * VIP email notifier.
 */
if ( ! class_exists( __NAMESPACE__ . '\VIP_Notifier' ) ) {
	class VIP_Notifier {
		/**
		 * Send email to prioritized customer and donors according to settings.
		 *
		 * @param \WC_Order $target
		 * @param array     $target_lines array of [ 'product' => WC_Product|null, 'name' => string, 'sku'=>string, 'qty' => int, 'eta'=>string ]
		 * @param array     $donor_map order_id => [ 'order' => WC_Order, 'lines' => [ ... same shape as above ... ] ]
		 */
		public static function notify( \WC_Order $target, array $target_lines, array $donor_map ): void {
			$opt = class_exists( __NAMESPACE__ . '\VIP_Settings' ) ? VIP_Settings::get() : array( 'enabled' => false );
			if ( empty( $opt['enabled'] ) ) {
				return;
			}
			$brand = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array();
			$logo  = (string) ( $brand['brand_logo_url'] ?? '' );
			$color = (string) ( $brand['brand_primary_color'] ?? '#1a1a1a' );
			$foot  = (string) ( $brand['email_footer_text_no'] ?? '' );

			$header = function( $title ) use ( $logo, $color ) {
				$logo_html = $logo ? '<div style="margin-bottom:12px;"><img src="' . esc_url( $logo ) . '" style="max-height:40px;" alt="" /></div>' : '';
				return '<div style="font-family:Arial,Helvetica,sans-serif;"><div>' . $logo_html . '</div><h2 style="color:' . esc_attr( $color ) . ';margin:0 0 12px 0;">' . esc_html( $title ) . '</h2>';
			};
			$list  = function( array $lines ): string {
				if ( empty( $lines ) ) { return ''; }
				$html = '<table cellspacing="0" cellpadding="6" border="0" style="width:100%;border-collapse:collapse;">';
				$html .= '<thead><tr><th align="left">' . esc_html__( 'Item', 'lpr-backorder-allocator' ) . '</th><th align="left">' . esc_html__( 'Qty', 'lpr-backorder-allocator' ) . '</th><th align="left">' . esc_html__( 'ETA', 'lpr-backorder-allocator' ) . '</th></tr></thead><tbody>';
				foreach ( $lines as $l ) {
					$name = (string) ( $l['name'] ?? '' );
					$sku  = (string) ( $l['sku'] ?? '' );
					$qty  = (int) ( $l['qty'] ?? 0 );
					$eta  = (string) ( $l['eta'] ?? '' );
					$html .= '<tr><td>' . esc_html( $name . ( $sku ? " [$sku]" : '' ) ) . '</td><td>' . esc_html( (string) $qty ) . '</td><td>' . esc_html( $eta ) . '</td></tr>';
				}
				$html .= '</tbody></table>';
				return $html;
			};
			$footer = function() use ( $foot ) {
				return $foot ? '<p style="margin-top:16px;color:#777;font-size:12px;">' . wp_kses_post( $foot ) . '</p></div>' : '</div>';
			};

			// Prioritized order email.
			if ( ! empty( $opt['notify_prioritized'] ) ) {
				$email = $target->get_billing_email();
				if ( $email ) {
					$subject = (string) ( $opt['subject_prioritized'] ?? __( 'We prioritized your order', 'lpr-backorder-allocator' ) );
					$body    = $header( $subject );
					$body   .= '<p>' . esc_html__( 'Great news — your order has been moved to the front of the queue for these items:', 'lpr-backorder-allocator' ) . '</p>';
					$body   .= $list( $target_lines );
					$body   .= $footer();
					self::send_mail( $email, $subject, $body );
				}
			}

			// Donor order emails.
			if ( ! empty( $opt['notify_donor'] ) && ! empty( $donor_map ) ) {
				foreach ( $donor_map as $donor ) {
					if ( empty( $donor['order'] ) || empty( $donor['lines'] ) ) { continue; }
					/** @var \WC_Order $dorder */
					$dorder  = $donor['order'];
					$email   = $dorder->get_billing_email();
					if ( ! $email ) { continue; }
					$subject = (string) ( $opt['subject_donor'] ?? __( 'Update: your allocation has changed', 'lpr-backorder-allocator' ) );
					$body    = $header( $subject );
					$body   .= '<p>' . esc_html__( 'We’ve reallocated some incoming stock to prioritize another order. The items below will receive the next available stock thereafter:', 'lpr-backorder-allocator' ) . '</p>';
					$body   .= $list( $donor['lines'] );
					$body   .= $footer();
					self::send_mail( $email, $subject, $body );
				}
			}
		}
		protected static function send_mail( string $to, string $subject, string $html ): void {
			if ( function_exists( 'wc_mail' ) ) {
				wc_mail( $to, $subject, $html, array( 'Content-Type: text/html; charset=UTF-8' ) );
			} else {
				wp_mail( $to, $subject, $html, array( 'Content-Type: text/html; charset=UTF-8' ) );
			}
		}
	}
}

/**
 * VIP Prioritization worker: reassign allocations from oldest allocated orders to target order.
 */
if ( ! class_exists( __NAMESPACE__ . '\VIP_Prioritize_Service' ) ) {
	class VIP_Prioritize_Service {

		public static function init(): void {
			add_action( 'admin_post_lpr_prioritize_order', array( __CLASS__, 'handle_request' ) );
			add_action( 'lpr_allocator_prioritize_order', array( __CLASS__, 'run' ), 10, 1 );
		}

		public static function handle_request(): void {
			$order_id = isset( $_GET['order_id'] ) ? absint( $_GET['order_id'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			$nonce    = isset( $_GET['_wpnonce'] ) ? (string) $_GET['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			if ( ! current_user_can( 'edit_post', $order_id ) ) {
				wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) );
			}
			if ( $order_id <= 0 || ! wp_verify_nonce( $nonce, 'lpr_prioritize_' . $order_id ) ) {
				wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
			}
			$redirect = get_edit_post_link( $order_id, 'url' );
			$queued   = false;
			if ( function_exists( 'as_enqueue_async_action' ) ) {
				as_enqueue_async_action( 'lpr_allocator_prioritize_order', array( 'order_id' => $order_id ), 'lpr-allocator' );
				$queued = true;
			} elseif ( function_exists( 'as_schedule_single_action' ) ) {
				as_schedule_single_action( time(), 'lpr_allocator_prioritize_order', array( 'order_id' => $order_id ), 'lpr-allocator' );
				$queued = true;
			} else {
				self::run( $order_id );
			}
			wp_safe_redirect( add_query_arg( array( 'lpr_vip' => $queued ? 'queued' : 'done' ), $redirect ) );
			exit;
		}

		/**
		 * Execute prioritization for an order.
		 *
		 * @param int $order_id
		 * @return void
		 */
		public static function run( int $order_id ): void {
			if ( ! function_exists( 'wc_get_order' ) ) {
				return;
			}
			$order = wc_get_order( $order_id );
			if ( ! ( $order instanceof \WC_Order ) ) {
				return;
			}
			$vip = class_exists( __NAMESPACE__ . '\VIP_Settings' ) ? VIP_Settings::get() : array( 'enabled' => false );
			if ( empty( $vip['enabled'] ) ) {
				return;
			}

			$needs_map = self::build_needs_map( $order );
			if ( empty( $needs_map ) ) {
				return;
			}

			$target_summary = array(); // for email: list of moved lines for target
			$donor_summary  = array(); // donor_id => [ 'order'=>WC_Order, 'lines'=>[] ]

			foreach ( $needs_map as $pid => $entry ) {
				$remaining = (int) $entry['need'];
				if ( $remaining <= 0 ) {
					continue;
				}
				$target_item_id = (int) $entry['item_id'];
				$prod           = wc_get_product( $pid );
				$sku            = ( $prod instanceof \WC_Product ) ? $prod->get_sku() : '';
				$lock_key       = 'lpr_vip_lock_' . md5( $sku ? 'sku:' . $sku : 'id:' . $pid );
				if ( get_transient( $lock_key ) ) {
					continue;
				}
				set_transient( $lock_key, 1, 120 );

				try {
					$transferred = self::steal_for_product( $order, $pid, $target_item_id, $remaining, $target_summary, $donor_summary );
					if ( $transferred > 0 && class_exists( __NAMESPACE__ . '\ETA' ) ) {
						ETA::update_line_eta( (int) $order->get_id() );
					}
				} finally {
					delete_transient( $lock_key );
				}
			}

			// Email notifications + notes.
			if ( ! empty( $target_summary ) || ! empty( $donor_summary ) ) {
				// Order notes for target.
				$order->add_order_note( __( 'VIP prioritization applied. Some allocations were reassigned from older orders to this order.', 'lpr-backorder-allocator' ), false, true );
				// Donor orders notes and ETA refresh.
				foreach ( $donor_summary as $did => $d ) {
					if ( isset( $d['order'] ) && $d['order'] instanceof \WC_Order ) {
						$d['order']->add_order_note( __( 'Some allocations were reassigned to prioritize another order. ETA may shift based on remaining allocations.', 'lpr-backorder-allocator' ), false, true );
						if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
							ETA::update_line_eta( (int) $did );
						}
					}
				}
				// Send emails if enabled.
				if ( class_exists( __NAMESPACE__ . '\VIP_Notifier' ) ) {
					VIP_Notifier::notify( $order, $target_summary, $donor_summary );
				}
			}
		}

		/**
		 * Build map of product_id => [item_id, need]
		 */
		protected static function build_needs_map( \WC_Order $order ): array {
			$map = array();
			foreach ( $order->get_items( 'line_item' ) as $item ) {
				if ( ! ( $item instanceof \WC_Order_Item_Product ) ) { continue; }
				if ( class_exists( __NAMESPACE__ . '\Backorder' ) && ! Backorder::needs_allocation( $item ) ) { continue; }
				$need = function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_need' ) ? lpr_allocator_calc_backorder_need( $item ) : 0;
				if ( $need <= 0 ) { continue; }
				$pid = (int) ( $item->get_variation_id() ?: $item->get_product_id() );
				if ( $pid <= 0 ) { continue; }
				// Prefer a single target item per product: choose the first with need.
				if ( empty( $map[ $pid ] ) ) {
					$map[ $pid ] = array(
						'item_id' => (int) $item->get_id(),
						'need'    => (int) $need,
					);
				} else {
					$map[ $pid ]['need'] += (int) $need;
				}
			}
			return $map;
		}

		/**
		 * Steal allocations for a single product from oldest allocated orders (excluding target).
		 *
		 * @param \WC_Order $target_order
		 * @param int       $product_id
		 * @param int       $target_item_id
		 * @param int       $need_qty
		 * @param array     &$target_summary
		 * @param array     &$donor_summary
		 * @return int moved total
		 */
		protected static function steal_for_product( \WC_Order $target_order, int $product_id, int $target_item_id, int $need_qty, array &$target_summary, array &$donor_summary ): int {
			if ( $need_qty <= 0 ) {
				return 0;
			}
			$settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
			$statuses = array();
			foreach ( (array) $settings['order_statuses'] as $st ) {
				$statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
			}
			$target_ts = self::order_ts( $target_order );

			$moved_total = 0;
			$page        = 1;
			$limit       = 50;

			$meta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';

			// Find donor orders in ascending date until we pass the target order timestamp.
			do {
				$args = array(
					'status'  => $statuses,
					'limit'   => $limit,
					'page'    => $page,
					'orderby' => 'date',
					'order'   => 'ASC',
					'return'  => 'ids',
					'type'    => 'shop_order',
				);
				$ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
				if ( empty( $ids ) ) {
					break;
				}
				foreach ( $ids as $oid ) {
					if ( $moved_total >= $need_qty ) {
						break 2;
					}
					if ( (int) $oid === (int) $target_order->get_id() ) {
						continue;
					}
					$donor = wc_get_order( $oid );
					if ( ! ( $donor instanceof \WC_Order ) ) {
						continue;
					}
					$donor_ts = self::order_ts( $donor );
					// Stop scanning once we hit the target order's time window.
					if ( $donor_ts >= $target_ts ) {
						break 2;
					}

					// Look for donor items for this product with active allocations.
					foreach ( $donor->get_items( 'line_item' ) as $ditem ) {
						if ( ! ( $ditem instanceof \WC_Order_Item_Product ) ) { continue; }
						$pid = (int) ( $ditem->get_variation_id() ?: $ditem->get_product_id() );
						if ( $pid !== $product_id ) { continue; }

						$allocs = $ditem->get_meta( $meta_key, true );
						if ( ! is_array( $allocs ) || empty( $allocs ) ) { continue; }

						// Compute active alloc qty and sort rows by allocated_at ASC (oldest first).
						$rows = array();
						$active_total = 0;
						foreach ( $allocs as $idx => $row ) {
							$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
							$q      = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
							if ( 'released' === $status || $q <= 0 ) { continue; }
							$ts = 0;
							if ( ! empty( $row['allocated_at'] ) ) {
								$ts = strtotime( (string) $row['allocated_at'] ) ?: 0;
							}
							$rows[] = array( 'i' => $idx, 'q' => $q, 'ts' => $ts, 'row' => $row );
							$active_total += $q;
						}
						if ( $active_total <= 0 ) { continue; }
						usort( $rows, static function( $a, $b ) { return ( $a['ts'] <=> $b['ts'] ); } );

						// Load target item.
						$target_item = null;
						foreach ( $target_order->get_items( 'line_item' ) as $titem ) {
							if ( $titem->get_id() === $target_item_id ) { $target_item = $titem; break; }
						}
						if ( ! ( $target_item instanceof \WC_Order_Item_Product ) ) { continue; }

						$remaining = $need_qty - $moved_total;
						if ( $remaining <= 0 ) { break 2; }

						$today_dt = current_time( 'mysql' );
						$t_allocs = $target_item->get_meta( $meta_key, true );
						if ( ! is_array( $t_allocs ) ) { $t_allocs = array(); }

						// Move from donor rows to target until satisfied.
						foreach ( $rows as $info ) {
							if ( $remaining <= 0 ) { break; }
							$idx = (int) $info['i'];
							$q   = (int) $info['q'];
							if ( $q <= 0 ) { continue; }

							$take = min( $q, $remaining );
							$remaining -= $take;
							$moved_total += $take;

							// Decrease donor row qty.
							$allocs[ $idx ]['qty_allocated'] = max( 0, (int) $allocs[ $idx ]['qty_allocated'] - $take );

							// Record a released entry on donor for the moved qty (audit trail).
							$rel = array(
								'po_id'         => isset( $info['row']['po_id'] ) ? (int) $info['row']['po_id'] : 0,
								'po_number'     => isset( $info['row']['po_number'] ) ? (string) $info['row']['po_number'] : '',
								'qty_allocated' => (int) $take,
								'eta'           => isset( $info['row']['eta'] ) ? (string) $info['row']['eta'] : '',
								'status'        => 'released',
								'released_at'   => $today_dt,
							);
							$allocs[] = $rel;

							// Append to target allocations.
							$t_allocs[] = array(
								'po_id'         => $rel['po_id'],
								'po_number'     => $rel['po_number'],
								'qty_allocated' => (int) $take,
								'eta'           => $rel['eta'],
								'status'        => 'reserved',
								'allocated_at'  => $today_dt,
							);

							// Summaries for email.
							$prod   = wc_get_product( $product_id );
							$name   = $target_item->get_name();
							$sku    = ( $prod instanceof \WC_Product ) ? $prod->get_sku() : '';
							$ts_row = array( 'product' => $prod, 'name' => $name, 'sku' => $sku, 'qty' => $take, 'eta' => (string) $rel['eta'] );
							$target_summary[] = $ts_row;

							if ( empty( $donor_summary[ (int) $donor->get_id() ] ) ) {
								$donor_summary[ (int) $donor->get_id() ] = array( 'order' => $donor, 'lines' => array() );
							}
							$donor_summary[ (int) $donor->get_id() ]['lines'][] = $ts_row;
						}

						// Persist donor + target item metas.
						$ditem->update_meta_data( $meta_key, $allocs );
						$ditem->save();

						$target_item->update_meta_data( $meta_key, $t_allocs );
						$target_item->save();

						// Notes per donor move (concise).
						if ( $moved_total > 0 ) {
							$prod = wc_get_product( $product_id );
							$sku  = ( $prod instanceof \WC_Product ) ? $prod->get_sku() : '';
							$note_d = sprintf(
								/* translators: 1: qty, 2: item name, 3: SKU, 4: target order number */
								__( 'VIP: Reassigned %1$s x %2$s%3$s to order #%4$s.', 'lpr-backorder-allocator' ),
								(int) $moved_total,
								$ditem->get_name(),
								$sku ? ' [' . $sku . ']' : '',
								$target_order->get_order_number()
							);
							$donor->add_order_note( $note_d, false, true );

							$note_t = sprintf(
								__( 'VIP: Received %1$s x %2$s%3$s from order #%4$s.', 'lpr-backorder-allocator' ),
								(int) $moved_total,
								$target_item->get_name(),
								$sku ? ' [' . $sku . ']' : '',
								$donor->get_order_number()
							);
							$target_order->add_order_note( $note_t, false, true );
						}

						if ( $moved_total >= $need_qty ) {
							break 2;
						}
					}
				}
				$page++;
			} while ( true );

			return $moved_total;
		}

		protected static function order_ts( \WC_Order $order ): int {
			$paid = $order->get_date_paid();
			$created = $order->get_date_created();
			return $paid ? (int) $paid->getTimestamp() : ( $created ? (int) $created->getTimestamp() : 0 );
		}
	}
	VIP_Prioritize_Service::init();
}

/* SELF-CHECK:
- Added VIP_Settings option (key lpr_allocator_vip_settings, autoload=no) with toggles for enabling feature and customer notifications (prioritized + donor) and customizable subjects.
- Appended a new "VIP Prioritization" section to the existing WooCommerce → Settings → Backorders tab without modifying prior classes; handled render/save via hooks 'woocommerce_settings_tabs_lpr_backorders' and 'woocommerce_update_options_lpr_backorders'. Capability + nonce checks included.
- Added Order_Prioritize_UI meta box on order screens (classic + HPOS) that shows a "Prioritize (VIP)" button only when the order has backordered need and other orders hold allocations; visibility uses Backorder_Indexer snapshot when available, else a light scan. Includes admin notices on queue/completion.
- Implemented VIP_Prioritize_Service with admin-post handler (nonce + manage_woocommerce required) that enqueues an Action Scheduler job 'lpr_allocator_prioritize_order' with inline fallback. Worker reassigns allocation rows from the oldest allocated orders to the target order per product, using Woo CRUD only; per-SKU transient locks; server-side pagination via wc_get_orders; no wildcard meta_query; no stock writes.
- Allocation ledger integrity: donor rows reduced and a 'released' audit row appended; target receives equivalent 'reserved' rows preserving PO id/number/ETA. ETA::update_line_eta invoked for affected orders. Order notes added.
- Added VIP_Notifier to send HTML emails (toggleable/off) to the prioritized customer and donors; branding values reused from main Settings (logo, color, footer).
- All declarations are new and guarded; no re-declares; admin/cron only due to early return at file top; HPOS-safe.
*/
namespace LPR\Allocator;
if ( ! is_admin() && ! wp_doing_cron() ) { return; }

/**
 * -------------------------------------------------------------------------
 * Batch 7 — PO → Orders Overview (which orders this PO serves)
 * -------------------------------------------------------------------------
 * Shows, on a Supplier PO edit screen, which orders/line items have active
 * allocations pointing to this PO. Includes CSV export and an email stub.
 *
 * - HPOS/CRUD only (wc_get_orders, wc_get_order, wc_get_product, $order->get_items()).
 * - No stock changes; reads/writes only options and meta.
 * - Server-side pagination with a bounded scan window (default 20 pages).
 * - Guards against redeclarations; admin-only load.
 * - Text domain: 'lpr-backorder-allocator'.
 */
if ( ! class_exists( __NAMESPACE__ . '\PO_Orders_Overview_UI' ) ) {
	class PO_Orders_Overview_UI {

		const DEFAULT_SCAN_PAGES = 20;  // Default "window" of orders pages to scan (50 orders per page)
		const ACTION_EXPORT      = 'lpr_po_orders_overview_csv';
		const ACTION_EMAIL_STUB  = 'lpr_po_orders_overview_email';
		const NOTICE_PARAM       = 'lpr_poov_notice';

		public static function init(): void {
			add_action( 'add_meta_boxes', array( __CLASS__, 'register_box' ), 100 );

			// Actions for Export CSV and Email stub (cap + nonce protected).
			add_action( 'admin_post_' . self::ACTION_EXPORT, array( __CLASS__, 'handle_export_csv' ) );
			add_action( 'admin_post_' . self::ACTION_EMAIL_STUB, array( __CLASS__, 'handle_email_stub' ) );

			// Admin notices for stubs/results.
			add_action( 'admin_notices', array( __CLASS__, 'maybe_notice' ) );
		}

		public static function register_box(): void {
			if ( ! current_user_can( 'edit_posts' ) ) { return; }
			if ( ! defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ) { return; }

			add_meta_box(
				'lpr_po_orders_overview',
				__( 'This PO serves these orders', 'lpr-backorder-allocator' ),
				array( __CLASS__, 'render_box' ),
				CPT_SUPPLIER_PO,
				'normal',
				'default'
			);
		}

		/**
		 * Render the overview metabox on the PO edit screen.
		 */
		public static function render_box( \WP_Post $post ): void {
			if ( ! current_user_can( 'edit_post', $post->ID ) ) { return; }
			if ( ! defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) || $post->post_type !== CPT_SUPPLIER_PO ) { return; }

			$po_id = (int) $post->ID;

			// Controls (GET) – starting page and scan window size.
			$start_page = isset( $_GET['lpr_poov_start'] ) ? max( 1, absint( $_GET['lpr_poov_start'] ) ) : 1; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			$scan_pages = isset( $_GET['lpr_poov_scan'] ) ? max( 1, min( 50, absint( $_GET['lpr_poov_scan'] ) ) ) : self::DEFAULT_SCAN_PAGES; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

			// Collect rows.
			$result = self::collect_rows_for_po( $po_id, $start_page, $scan_pages );
			$rows           = $result['rows'];
			$found          = (int) $result['found'];
			$scanned_pages  = (int) $result['scanned_pages'];
			$end_page       = ( $start_page - 1 ) + $scanned_pages;
			$next_start     = max( 1, $end_page + 1 );

			// Build action URLs (CSV / Email stub / Load more), all nonce-protected.
			$csv_nonce   = wp_create_nonce( self::ACTION_EXPORT . '_' . $po_id . '_' . $start_page . '_' . $scan_pages );
			$email_nonce = wp_create_nonce( self::ACTION_EMAIL_STUB . '_' . $po_id . '_' . $start_page . '_' . $scan_pages );

			$csv_url = add_query_arg(
				array(
					'action'   => self::ACTION_EXPORT,
					'po_id'    => $po_id,
					'start'    => $start_page,
					'scan'     => $scan_pages,
					'_wpnonce' => $csv_nonce,
				),
				admin_url( 'admin-post.php' )
			);

			$email_url = add_query_arg(
				array(
					'action'   => self::ACTION_EMAIL_STUB,
					'po_id'    => $po_id,
					'start'    => $start_page,
					'scan'     => $scan_pages,
					'_wpnonce' => $email_nonce,
				),
				admin_url( 'admin-post.php' )
			);

			$load_more_url = add_query_arg(
				array(
					'post'           => $po_id,
					'action'         => 'edit',
					'lpr_poov_start' => $next_start,
					'lpr_poov_scan'  => $scan_pages,
				),
				admin_url( 'post.php' )
			);

			// Scan window adjust form (GET).

			?>
			<style>
				.lpr-poov-header { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin:6px 0 10px; }
				.lpr-poov-meta { opacity:.8; }
				.lpr-poov-actions a.button { margin-right:6px; }
				table.lpr-poov { width:100%; border-collapse: collapse; }
				table.lpr-poov th, table.lpr-poov td { padding:6px 8px; border-bottom:1px solid #e2e2e2; text-align:left; }
				table.lpr-poov th.num, table.lpr-poov td.num { text-align:right; white-space:nowrap; }
				table.lpr-poov td.small { font-size:12px; opacity:.9; }
			</style>

			<div class="lpr-poov-header">
				<div class="lpr-poov-actions">
					<a class="button button-secondary" href="<?php echo esc_url( $csv_url ); ?>"><?php echo esc_html__( 'Export CSV', 'lpr-backorder-allocator' ); ?></a>
					<a class="button" href="<?php echo esc_url( $email_url ); ?>"><?php echo esc_html__( 'Email customers (stub)', 'lpr-backorder-allocator' ); ?></a>
					<a class="button button-primary" href="<?php echo esc_url( $load_more_url ); ?>"><?php echo esc_html__( 'Load more', 'lpr-backorder-allocator' ); ?></a>
				</div>
				<div class="lpr-poov-adjust" style="margin-left:auto;">
					<label>
						<?php echo esc_html__( 'Pages per scan', 'lpr-backorder-allocator' ); ?>
						<input type="number" min="1" max="50" id="lpr_poov_scan" value="<?php echo esc_attr( (string) $scan_pages ); ?>" style="width:80px;">
					</label>
					<label style="margin-left:8px;">
						<?php echo esc_html__( 'Start page', 'lpr-backorder-allocator' ); ?>
						<input type="number" min="1" id="lpr_poov_start" value="<?php echo esc_attr( (string) $start_page ); ?>" style="width:80px;">
					</label>
					<button type="button" class="button" id="lpr_poov_apply"><?php echo esc_html__( 'Apply', 'lpr-backorder-allocator' ); ?></button>
				</div>
				<script>
				(function(){
					var btn = document.getElementById('lpr_poov_apply');
					if (!btn) return;
					btn.addEventListener('click', function () {
						var base = <?php echo wp_json_encode( add_query_arg(
							array( 'post' => $po_id, 'action' => 'edit' ),
							admin_url( 'post.php' )
						) ); ?>;
						try {
							var u = new URL(base, window.location.origin);
							var scanEl = document.getElementById('lpr_poov_scan');
							var startEl = document.getElementById('lpr_poov_start');
							var scan = scanEl && scanEl.value ? scanEl.value : '';
							var start = startEl && startEl.value ? startEl.value : '';
							if (scan)  u.searchParams.set('lpr_poov_scan', scan);
							if (start) u.searchParams.set('lpr_poov_start', start);
							window.location.href = u.toString();
						} catch (e) {
							// Fallback without URL API support
							var qs = '';
							var scanEl = document.getElementById('lpr_poov_scan');
							var startEl = document.getElementById('lpr_poov_start');
							var scan = scanEl && scanEl.value ? scanEl.value : '';
							var start = startEl && startEl.value ? startEl.value : '';
							var s = encodeURIComponent((scan || '').toString());
							var st = encodeURIComponent((start || '').toString());
							if (s)  qs += (qs ? '&' : '?') + 'lpr_poov_scan=' + s;
							if (st) qs += (qs ? '&' : '?') + 'lpr_poov_start=' + st;
							window.location.href = base + qs;
						}
					});
				})();
				</script>
			</div>

			<p class="lpr-poov-meta">
				<?php
				echo esc_html(
					sprintf(
						/* translators: 1: start page, 2: end page, 3: found count */
						__( 'Scanned pages %1$s–%2$s. Matches found: %3$s.', 'lpr-backorder-allocator' ),
						number_format_i18n( $start_page ),
						number_format_i18n( $end_page ),
						number_format_i18n( $found )
					)
				);
				?>
			</p>

			<table class="widefat striped lpr-poov">
				<thead>
					<tr>
						<th><?php echo esc_html__( 'Order #', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Customer', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Product (SKU)', 'lpr-backorder-allocator' ); ?></th>
						<th class="num"><?php echo esc_html__( 'Qty allocated', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Item ETA', 'lpr-backorder-allocator' ); ?></th>
						<th><?php echo esc_html__( 'Allocation status', 'lpr-backorder-allocator' ); ?></th>
					</tr>
				</thead>
				<tbody>
					<?php if ( empty( $rows ) ) : ?>
						<tr><td colspan="6"><?php echo esc_html__( 'No orders found in this scan window. Use “Load more” or increase the pages per scan.', 'lpr-backorder-allocator' ); ?></td></tr>
					<?php else : ?>
						<?php foreach ( $rows as $r ) : ?>
							<tr>
								<td>
									<?php if ( ! empty( $r['order_edit_url'] ) ) : ?>
										<a href="<?php echo esc_url( $r['order_edit_url'] ); ?>">#<?php echo esc_html( (string) $r['order_number'] ); ?></a>
									<?php else : ?>
										#<?php echo esc_html( (string) $r['order_number'] ); ?>
									<?php endif; ?>
								</td>
								<td class="small">
									<?php echo esc_html( $r['customer_name'] ); ?>
									<?php if ( ! empty( $r['customer_email'] ) ) : ?>
										<br><span class="description"><?php echo esc_html( $r['customer_email'] ); ?></span>
									<?php endif; ?>
								</td>
								<td class="small">
									<?php echo esc_html( $r['product_label'] ); ?>
									<?php if ( ! empty( $r['sku'] ) ) : ?>
										<br><span class="description"><?php echo esc_html( '[' . $r['sku'] . ']' ); ?></span>
									<?php endif; ?>
								</td>
								<td class="num"><?php echo esc_html( (string) $r['qty_allocated'] ); ?></td>
								<td><?php echo esc_html( $r['item_eta'] ); ?></td>
								<td><?php echo esc_html( $r['alloc_status'] ); ?></td>
							</tr>
						<?php endforeach; ?>
					<?php endif; ?>
				</tbody>
			</table>
			<?php
		}

		/**
		 * Collect aggregated rows for this PO by scanning orders in a bounded window.
		 *
		 * @return array{rows: array<int,array>, found:int, scanned_pages:int}
		 */
		protected static function collect_rows_for_po( int $po_id, int $start_page, int $scan_pages ): array {
			$rows          = array(); // keyed by "order_id|item_id"
			$found         = 0;
			$scanned_pages = 0;

			// Build statuses from primary settings (bare slug -> 'wc-...').
			$settings  = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
			$statuses  = array();
			foreach ( (array) ( $settings['order_statuses'] ?? array() ) as $st ) {
				$statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
			}
			$statuses = array_values( array_unique( $statuses ) );

			$key_allocs = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
			$key_eta    = defined( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA' ) ? ORDER_ITEM_META_LINE_ETA : '_lpr_line_eta';

			$end_page = $start_page + max( 0, $scan_pages - 1 );

			for ( $page = $start_page; $page <= $end_page; $page++ ) {
				$args = array(
					'status'  => $statuses,
					'limit'   => 50,
					'page'    => $page,
					'orderby' => 'date',
					'order'   => 'ASC',
					'return'  => 'ids',
					'type'    => 'shop_order',
				);
				$order_ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
				if ( empty( $order_ids ) ) { $scanned_pages++; break; }

				foreach ( $order_ids as $oid ) {
					$order = wc_get_order( $oid );
					if ( ! ( $order instanceof \WC_Order ) ) { continue; }

					$order_number = method_exists( $order, 'get_order_number' ) ? $order->get_order_number() : (string) $order->get_id();
					$edit_url     = method_exists( $order, 'get_edit_order_url' ) ? $order->get_edit_order_url() : get_edit_post_link( $order->get_id(), 'url' );
					$cust_name    = trim( (string) $order->get_formatted_billing_full_name() );
					if ( '' === $cust_name ) {
						$first = (string) $order->get_billing_first_name();
						$last  = (string) $order->get_billing_last_name();
						$cust_name = trim( $first . ' ' . $last );
					}
					if ( '' === $cust_name ) {
						$cust_name = __( 'Guest', 'lpr-backorder-allocator' );
					}
					$cust_email = (string) $order->get_billing_email();

					foreach ( $order->get_items( 'line_item' ) as $item ) {
						if ( ! ( $item instanceof \WC_Order_Item_Product ) ) { continue; }

						$allocs = $item->get_meta( $key_allocs, true );
						if ( ! is_array( $allocs ) || empty( $allocs ) ) { continue; }

						// Aggregate active rows for this PO.
						$qty_for_item     = 0;
						$any_reserved     = false;
						$any_nonreleased  = false;

						foreach ( $allocs as $row ) {
							$rid    = isset( $row['po_id'] ) ? absint( $row['po_id'] ) : 0;
							$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
							$qty    = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;

							if ( $rid === $po_id && $qty > 0 && 'released' !== $status ) {
								$qty_for_item     += $qty;
								$any_nonreleased   = true;
								if ( 'reserved' === $status ) {
									$any_reserved = true;
								}
							}
						}

						if ( $qty_for_item <= 0 || ! $any_nonreleased ) {
							continue;
						}

						$target_id = (int) ( $item->get_variation_id() ?: $item->get_product_id() );
						$sku       = '';
						$label     = '#' . ( $target_id ?: 0 );
						if ( function_exists( 'wc_get_product' ) ) {
							$p   = wc_get_product( $target_id );
							$sku = ( $p instanceof \WC_Product ) ? (string) $p->get_sku() : '';
						}
						if ( function_exists( __NAMESPACE__ . '\lpr_allocator_product_option_label' ) && $target_id > 0 ) {
							$label = lpr_allocator_product_option_label( $target_id );
						}

						$eta = (string) $item->get_meta( $key_eta, true );

						// Key by order_id + item_id to avoid duplicates from multiple rows.
						$rk = (int) $order->get_id() . '|' . (int) $item->get_id();
						if ( ! isset( $rows[ $rk ] ) ) {
							$rows[ $rk ] = array(
								'order_id'       => (int) $order->get_id(),
								'order_number'   => (string) $order_number,
								'order_edit_url' => (string) $edit_url,
								'customer_name'  => (string) $cust_name,
								'customer_email' => (string) $cust_email,
								'product_label'  => (string) $label,
								'sku'            => (string) $sku,
								'qty_allocated'  => 0,
								'item_eta'       => (string) $eta,
								'alloc_status'   => $any_reserved ? 'reserved' : 'active',
								// For potential sorting:
								'paid_ts'        => $order->get_date_paid() ? (int) $order->get_date_paid()->getTimestamp() : null,
								'created_ts'     => $order->get_date_created() ? (int) $order->get_date_created()->getTimestamp() : 0,
							);
						}
						$rows[ $rk ]['qty_allocated'] += (int) $qty_for_item;
						// If mixed statuses are possible in future, mark mixed.
						if ( isset( $rows[ $rk ]['alloc_status'] ) && $rows[ $rk ]['alloc_status'] !== ( $any_reserved ? 'reserved' : 'active' ) ) {
							$rows[ $rk ]['alloc_status'] = 'mixed';
						}

						$found++;
					}
				}

				$scanned_pages++;
			}

			// Sort rows: paid date ASC (fallback created), then order number.
			if ( ! empty( $rows ) ) {
				uasort(
					$rows,
					static function( $a, $b ) {
						$ap = isset( $a['paid_ts'] ) && null !== $a['paid_ts'] ? (int) $a['paid_ts'] : (int) $a['created_ts'];
						$bp = isset( $b['paid_ts'] ) && null !== $b['paid_ts'] ? (int) $b['paid_ts'] : (int) $b['created_ts'];
						if ( $ap !== $bp ) { return $ap <=> $bp; }
						return strnatcasecmp( (string) $a['order_number'], (string) $b['order_number'] );
					}
				);
			}

			return array(
				'rows'          => array_values( $rows ),
				'found'         => (int) $found,
				'scanned_pages' => (int) $scanned_pages,
			);
		}

		/**
		 * CSV export handler (exports exactly what the current window shows).
		 */
		public static function handle_export_csv(): void {
			$po_id      = isset( $_GET['po_id'] ) ? absint( $_GET['po_id'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			$start_page = isset( $_GET['start'] ) ? max( 1, absint( $_GET['start'] ) ) : 1; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			$scan_pages = isset( $_GET['scan'] ) ? max( 1, min( 50, absint( $_GET['scan'] ) ) ) : self::DEFAULT_SCAN_PAGES; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			$nonce      = isset( $_GET['_wpnonce'] ) ? (string) $_GET['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

			if ( ! current_user_can( 'edit_post', $po_id ) ) {
				wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) );
			}
			if ( $po_id <= 0 || ! wp_verify_nonce( $nonce, self::ACTION_EXPORT . '_' . $po_id . '_' . $start_page . '_' . $scan_pages ) ) {
				wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
			}

			$res  = self::collect_rows_for_po( $po_id, $start_page, $scan_pages );
			$rows = $res['rows'];

			nocache_headers();
			header( 'Content-Type: text/csv; charset=UTF-8' );
			header( 'Content-Disposition: attachment; filename="po-' . (int) $po_id . '-orders-overview.csv"' );

			$out = fopen( 'php://output', 'w' );
			if ( $out ) {
				// Header row.
				fputcsv( $out, array( 'OrderNumber', 'OrderID', 'CustomerName', 'CustomerEmail', 'Product', 'SKU', 'QtyAllocated', 'ItemETA', 'AllocationStatus' ) );
				foreach ( $rows as $r ) {
					fputcsv( $out, array(
						(string) $r['order_number'],
						(int)    $r['order_id'],
						(string) $r['customer_name'],
						(string) $r['customer_email'],
						(string) $r['product_label'],
						(string) $r['sku'],
						(int)    $r['qty_allocated'],
						(string) $r['item_eta'],
						(string) $r['alloc_status'],
					) );
				}
				fclose( $out );
			}
			exit;
		}

		/**
		 * Email customers stub: counts unique emails and shows a notice.
		 * (No real emails are sent in this stub.)
		 */
		public static function handle_email_stub(): void {
			$po_id      = isset( $_GET['po_id'] ) ? absint( $_GET['po_id'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			$start_page = isset( $_GET['start'] ) ? max( 1, absint( $_GET['start'] ) ) : 1; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			$scan_pages = isset( $_GET['scan'] ) ? max( 1, min( 50, absint( $_GET['scan'] ) ) ) : self::DEFAULT_SCAN_PAGES; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			$nonce      = isset( $_GET['_wpnonce'] ) ? (string) $_GET['_wpnonce'] : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended

			if ( ! current_user_can( 'edit_post', $po_id ) ) { wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) ); }
			if ( $po_id <= 0 || ! wp_verify_nonce( $nonce, self::ACTION_EMAIL_STUB . '_' . $po_id . '_' . $start_page . '_' . $scan_pages ) ) { wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) ); }

			$res    = self::collect_rows_for_po( $po_id, $start_page, $scan_pages );
			$rows   = $res['rows'];
			$emails = array();
			foreach ( $rows as $r ) {
				if ( ! empty( $r['customer_email'] ) ) {
					$emails[] = strtolower( trim( (string) $r['customer_email'] ) );
				}
			}
			$emails = array_values( array_unique( $emails ) );
			$count  = count( $emails );

			$redirect = add_query_arg(
				array(
					'post'                     => $po_id,
					'action'                   => 'edit',
					self::NOTICE_PARAM         => 'email_stub',
					'lpr_poov_count'           => $count,
					'lpr_poov_start'           => $start_page,
					'lpr_poov_scan'            => $scan_pages,
				),
				admin_url( 'post.php' )
			);

			wp_safe_redirect( $redirect );
			exit;
		}

		/**
		 * Admin notice handler for stubs/results.
		 */
		public static function maybe_notice(): void {
			if ( empty( $_GET[ self::NOTICE_PARAM ] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				return;
			}
			$type = sanitize_key( wp_unslash( $_GET[ self::NOTICE_PARAM ] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			if ( 'email_stub' === $type ) {
				$count = isset( $_GET['lpr_poov_count'] ) ? max( 0, absint( $_GET['lpr_poov_count'] ) ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				printf(
					'<div class="notice notice-success is-dismissible"><p>%s</p></div>',
					esc_html(
						sprintf(
							/* translators: %s: customer count */
							__( 'Email customers (stub): would notify %s customers.', 'lpr-backorder-allocator' ),
							number_format_i18n( $count )
						)
					)
				);
			}
		}
	}
	PO_Orders_Overview_UI::init();
}
namespace LPR\Allocator;
if ( ! is_admin() && ! wp_doing_cron() ) { return; }

/**
 * -------------------------------------------------------------------------
 * Batch 6 — Status Automation (“Ready to ship” / “Partially received”)
 * -------------------------------------------------------------------------
 * - Registers two custom order statuses (private but visible in admin)
 * - Adds settings to Woo "Backorders" tab
 * - Automates order status changes based on received/allocated progress
 * - Hooks on order/object saves, PO saves, and a nightly cron fallback
 *
 * Requirements honored:
 * - HPOS/CRUD only (wc_get_order(s), wc_get_product, $order->get_items())
 * - No stock changes; only options/meta writes
 * - Guarded declarations; admin/cron-only load
 * - Server-side pagination; short locks; avoid full scans outside cron
 * - Text domain: 'lpr-backorder-allocator'
 */

/** Status slugs (bare, as used by WC_Order::update_status). */
if ( ! defined( __NAMESPACE__ . '\ORDER_STATUS_READY' ) ) {
	define( __NAMESPACE__ . '\ORDER_STATUS_READY', 'lpr-ready-to-ship' );
}
if ( ! defined( __NAMESPACE__ . '\ORDER_STATUS_PARTIAL' ) ) {
	define( __NAMESPACE__ . '\ORDER_STATUS_PARTIAL', 'lpr-partially-received' );
}

/** Settings option key for this feature. */
if ( ! defined( __NAMESPACE__ . '\STATUS_AUTO_OPTION' ) ) {
	define( __NAMESPACE__ . '\STATUS_AUTO_OPTION', 'lpr_allocator_status_auto' );
}

/** Order meta to remember the previous status before automation. */
if ( ! defined( __NAMESPACE__ . '\ORDER_META_PREV_STATUS' ) ) {
	define( __NAMESPACE__ . '\ORDER_META_PREV_STATUS', '_lpr_status_auto_prev' );
}

/** Cron hook name (Action Scheduler + WP-Cron compatible). */
if ( ! defined( __NAMESPACE__ . '\STATUS_AUTO_CRON_HOOK' ) ) {
	define( __NAMESPACE__ . '\STATUS_AUTO_CRON_HOOK', 'lpr_allocator_status_auto_cron' );
}

/**
 * Register custom order statuses and expose them in admin lists.
 */
if ( ! class_exists( __NAMESPACE__ . '\Order_Status_Registry' ) ) {
	class Order_Status_Registry {
		public static function init(): void {
			add_action( 'init', array( __CLASS__, 'register' ) );
			add_filter( 'wc_order_statuses', array( __CLASS__, 'add_to_list' ) );
		}

		public static function register(): void {
			$defs = array(
				'wc-' . ORDER_STATUS_READY   => __( 'Ready to ship', 'lpr-backorder-allocator' ),
				'wc-' . ORDER_STATUS_PARTIAL => __( 'Partially received', 'lpr-backorder-allocator' ),
			);

			foreach ( $defs as $slug => $label ) {
				if ( ! get_post_status_object( $slug ) ) {
					register_post_status(
						$slug,
						array(
							'label'                     => $label,
							'public'                    => false,
							'internal'                  => false,
							'exclude_from_search'       => true,
							'show_in_admin_status_list' => true,
							'show_in_admin_all_list'    => true,
							'label_count'               => _n_noop(
								"$label <span class=\"count\">(%s)</span>",
								"$label <span class=\"count\">(%s)</span>",
								'lpr-backorder-allocator'
							),
						)
					);
				}
			}
		}

		public static function add_to_list( array $statuses ): array {
			$statuses[ 'wc-' . ORDER_STATUS_READY ]   = __( 'Ready to ship', 'lpr-backorder-allocator' );
			$statuses[ 'wc-' . ORDER_STATUS_PARTIAL ] = __( 'Partially received', 'lpr-backorder-allocator' );
			return $statuses;
		}
	}
	Order_Status_Registry::init();
}

/**
 * Persistence for automation settings.
 */
if ( ! class_exists( __NAMESPACE__ . '\Status_Auto_Settings' ) ) {
	class Status_Auto_Settings {
		public static function key(): string { return STATUS_AUTO_OPTION; }

		public static function defaults(): array {
			return array(
				'enabled'        => true,
				'mode'           => 'received_based', // 'received_based' (default) or 'allocated_based'
				'status_full'    => ORDER_STATUS_READY,
				'status_partial' => ORDER_STATUS_PARTIAL,
			);
		}

		public static function ensure_option(): void {
			if ( null === get_option( self::key(), null ) ) {
				add_option( self::key(), self::defaults(), '', 'no' );
			}
		}

		public static function get(): array {
			$stored = get_option( self::key(), array() );
			if ( ! is_array( $stored ) ) { $stored = array(); }
			$merged = array_replace( self::defaults(), $stored );

			// Sanity: force known modes and slugs.
			if ( ! in_array( $merged['mode'], array( 'received_based', 'allocated_based' ), true ) ) {
				$merged['mode'] = 'received_based';
			}
			$merged['status_full']    = sanitize_key( preg_replace( '/^wc-/', '', (string) $merged['status_full'] ) );
			$merged['status_partial'] = sanitize_key( preg_replace( '/^wc-/', '', (string) $merged['status_partial'] ) );

			return $merged;
		}

		public static function update( array $raw ): bool {
			$san = array(
				'enabled'        => ! empty( $raw['enabled'] ),
				'mode'           => in_array( $raw['mode'] ?? '', array( 'received_based', 'allocated_based' ), true ) ? $raw['mode'] : 'received_based',
				'status_full'    => sanitize_key( preg_replace( '/^wc-/', '', (string) ( $raw['status_full'] ?? ORDER_STATUS_READY ) ) ),
				'status_partial' => sanitize_key( preg_replace( '/^wc-/', '', (string) ( $raw['status_partial'] ?? ORDER_STATUS_PARTIAL ) ) ),
			);

			$exists = get_option( self::key(), null );
			if ( null === $exists ) {
				return add_option( self::key(), $san, '', 'no' );
			}
			return update_option( self::key(), $san, false );
		}
	}
	Status_Auto_Settings::ensure_option();
}

/**
 * Append a "Status Automation" section to Woo → Settings → Backorders tab.
 */
if ( ! class_exists( __NAMESPACE__ . '\Admin_Status_Auto_Settings' ) ) {
	class Admin_Status_Auto_Settings {
		public static function init(): void {
			add_action( 'woocommerce_settings_tabs_lpr_backorders', array( __CLASS__, 'render' ), 199 );
			add_action( 'woocommerce_update_options_lpr_backorders', array( __CLASS__, 'save' ), 199 );
			add_action( 'admin_init', array( __CLASS__, 'ensure_option' ) );
		}

		public static function ensure_option(): void {
			Status_Auto_Settings::ensure_option();
		}

		public static function render(): void {
			if ( ! current_user_can( 'edit_posts' ) ) {
				return;
			}
			$opt = Status_Auto_Settings::get();

			// Build order status select options (bare slugs).
			$wc_statuses = function_exists( 'wc_get_order_statuses' ) ? wc_get_order_statuses() : array();
			$opts = array();
			foreach ( $wc_statuses as $key => $label ) {
				$bare = preg_replace( '/^wc-/', '', $key );
				$opts[ $bare ] = $label;
			}
			?>
			<h2><?php echo esc_html__( 'Status Automation', 'lpr-backorder-allocator' ); ?></h2>
			<p class="description"><?php echo esc_html__( 'Automatically set order statuses when backordered items are received (or allocated, if configured). No stock changes are performed.', 'lpr-backorder-allocator' ); ?></p>
			<table class="form-table">
				<tr>
					<th scope="row"><?php esc_html_e( 'Enable automation', 'lpr-backorder-allocator' ); ?></th>
					<td>
						<label>
							<input type="checkbox" name="lpr_status_auto_enabled" value="1" <?php checked( $opt['enabled'], true ); ?> />
							<?php esc_html_e( 'Turn on automatic status changes', 'lpr-backorder-allocator' ); ?>
						</label>
					</td>
				</tr>
				<tr>
					<th scope="row"><?php esc_html_e( 'Mode', 'lpr-backorder-allocator' ); ?></th>
					<td>
						<select name="lpr_status_auto_mode">
							<option value="received_based" <?php selected( $opt['mode'], 'received_based' ); ?>><?php esc_html_e( 'Received-based (recommended)', 'lpr-backorder-allocator' ); ?></option>
							<option value="allocated_based" <?php selected( $opt['mode'], 'allocated_based' ); ?>><?php esc_html_e( 'Allocated-based', 'lpr-backorder-allocator' ); ?></option>
						</select>
						<p class="description"><?php esc_html_e( 'Received-based marks orders as items are physically received on Supplier POs. Allocated-based uses allocation ledger only.', 'lpr-backorder-allocator' ); ?></p>
					</td>
				</tr>
				<tr>
					<th scope="row"><?php esc_html_e( 'Target status — fully satisfied', 'lpr-backorder-allocator' ); ?></th>
					<td>
						<select name="lpr_status_auto_full">
							<?php foreach ( $opts as $slug => $label ) : ?>
								<option value="<?php echo esc_attr( $slug ); ?>" <?php selected( $opt['status_full'], $slug ); ?>><?php echo esc_html( $label ); ?></option>
							<?php endforeach; ?>
						</select>
						<p class="description"><?php esc_html_e( 'Default is "Ready to ship".', 'lpr-backorder-allocator' ); ?></p>
					</td>
				</tr>
				<tr>
					<th scope="row"><?php esc_html_e( 'Target status — partially satisfied', 'lpr-backorder-allocator' ); ?></th>
					<td>
						<select name="lpr_status_auto_partial">
							<?php foreach ( $opts as $slug => $label ) : ?>
								<option value="<?php echo esc_attr( $slug ); ?>" <?php selected( $opt['status_partial'], $slug ); ?>><?php echo esc_html( $label ); ?></option>
							<?php endforeach; ?>
						</select>
						<p class="description"><?php esc_html_e( 'Default is "Partially received".', 'lpr-backorder-allocator' ); ?></p>
					</td>
				</tr>
			</table>
			<?php
		}

		public static function save(): void {
			if ( ! current_user_can( 'edit_posts' ) ) {
				return;
			}
			if ( function_exists( 'check_admin_referer' ) ) {
				check_admin_referer( 'woocommerce-settings' );
			}
			$raw = array(
				'enabled'        => ! empty( $_POST['lpr_status_auto_enabled'] ),
				'mode'           => isset( $_POST['lpr_status_auto_mode'] ) ? (string) wp_unslash( $_POST['lpr_status_auto_mode'] ) : 'received_based',
				'status_full'    => isset( $_POST['lpr_status_auto_full'] ) ? (string) wp_unslash( $_POST['lpr_status_auto_full'] ) : ORDER_STATUS_READY,
				'status_partial' => isset( $_POST['lpr_status_auto_partial'] ) ? (string) wp_unslash( $_POST['lpr_status_auto_partial'] ) : ORDER_STATUS_PARTIAL,
			);
			Status_Auto_Settings::update( $raw );
		}
	}
	Admin_Status_Auto_Settings::init();
}

/**
 * Core automation worker.
 */
if ( ! class_exists( __NAMESPACE__ . '\Order_Status_Automation' ) ) {
	class Order_Status_Automation {

		/** Re-entrancy guard to avoid loops on update_status. */
		protected static $running = false;

		/** In-request cache for PO lines received pools: [po_id][target_id] => received_qty */
		protected static $po_received_cache = array();

		public static function init(): void {
			// Recompute on any order save (including item/meta saves).
			add_action( 'woocommerce_after_order_object_save', array( __CLASS__, 'on_order_saved' ), 100, 1 );

			// Recompute orders that reference a PO when that PO is saved.
			add_action( 'save_post', array( __CLASS__, 'on_po_saved' ), 20, 2 );

			// Nightly cron fallback (Action Scheduler preferred, WP-Cron fallback).
			add_action( STATUS_AUTO_CRON_HOOK, array( __CLASS__, 'run_cron' ) );
			add_action( 'admin_init', array( __CLASS__, 'maybe_schedule' ) );
		}

		/**
		 * Schedule nightly processing if not already present.
		 */
		public static function maybe_schedule(): void {
			// Prefer Action Scheduler if available.
			if ( function_exists( 'as_has_scheduled_action' ) && function_exists( 'as_schedule_recurring_action' ) ) {
				if ( ! as_has_scheduled_action( STATUS_AUTO_CRON_HOOK, array(), 'lpr-allocator' ) ) {
					as_schedule_recurring_action( time() + HOUR_IN_SECONDS, DAY_IN_SECONDS, STATUS_AUTO_CRON_HOOK, array(), 'lpr-allocator' );
				}
				return;
			}
			// Fallback to WP-Cron.
			if ( function_exists( 'wp_next_scheduled' ) && ! wp_next_scheduled( STATUS_AUTO_CRON_HOOK ) ) {
				wp_schedule_event( time() + HOUR_IN_SECONDS, 'daily', STATUS_AUTO_CRON_HOOK );
			}
		}

		/**
		 * Hook: order saved.
		 */
		public static function on_order_saved( $order ): void {
			if ( self::$running ) { return; }
			if ( ! ( $order instanceof \WC_Order ) ) { return; }
			self::recompute_for_order( (int) $order->get_id() );
		}

		/**
		 * Hook: PO saved → recompute orders referencing this PO only.
		 */
		public static function on_po_saved( int $post_id, $post ): void {
			if ( self::$running ) { return; }
			if ( defined( 'DOING_AUTOSAVE' ) && DOING_AUTOSAVE ) { return; }
			if ( wp_is_post_revision( $post_id ) ) { return; }
			if ( ! ( $post instanceof \WP_Post ) ) { return; }
			if ( ! defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ) { return; }
			if ( $post->post_type !== CPT_SUPPLIER_PO ) { return; }

			// Scan candidate orders that reference this PO id in any active allocation row.
		$order_ids = self::find_orders_referencing_po( $post_id );
if ( empty( $order_ids ) ) { return; }
foreach ( $order_ids as $oid ) {
	// NEW: keep order line ETAs in sync with any PO date change
	if ( class_exists( __NAMESPACE__ . '\ETA' ) ) {
		ETA::update_line_eta( (int) $oid );
	}
	// Existing behavior: recompute auto statuses
	self::recompute_for_order( (int) $oid );
}
		}

		/**
		 * Nightly sweep across active orders (processing/on-hold + our custom statuses).
		 */
		public static function run_cron(): void {
			if ( self::$running ) { return; }

			$scan_statuses = self::scan_statuses();
			$page  = 1;
			$limit = 50;

			do {
				$args = array(
					'status'  => $scan_statuses, // already 'wc-' prefixed
					'limit'   => $limit,
					'page'    => $page,
					'orderby' => 'date',
					'order'   => 'ASC',
					'return'  => 'ids',
					'type'    => 'shop_order',
				);
				$order_ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
				if ( empty( $order_ids ) ) { break; }

				foreach ( $order_ids as $oid ) {
					self::recompute_for_order( (int) $oid );
				}
				$page++;
			} while ( true );
		}

		/**
		 * Determine statuses to scan: configured + our custom ones.
		 *
		 * @return string[] Array of 'wc-...' statuses.
		 */
		protected static function scan_statuses(): array {
			$statuses = array();

			// From main Settings (order_statuses are bare slugs).
			$base = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
			foreach ( (array) ( $base['order_statuses'] ?? array() ) as $st ) {
				$statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
			}

			// Add our two custom statuses.
			$statuses[] = 'wc-' . ORDER_STATUS_READY;
			$statuses[] = 'wc-' . ORDER_STATUS_PARTIAL;

			// Deduplicate.
			$statuses = array_values( array_unique( $statuses ) );
			return $statuses;
		}

		/**
		 * Scan across configured statuses and return order IDs that reference a given PO id.
		 *
		 * @param int $po_id
		 * @return int[]
		 */
		protected static function find_orders_referencing_po( int $po_id ): array {
			$out   = array();
			$page  = 1;
			$limit = 50;
			$scan_statuses = self::scan_statuses();

			do {
				$args = array(
					'status'  => $scan_statuses,
					'limit'   => $limit,
					'page'    => $page,
					'orderby' => 'date',
					'order'   => 'ASC',
					'return'  => 'ids',
					'type'    => 'shop_order',
				);
				$order_ids = function_exists( 'wc_get_orders' ) ? wc_get_orders( $args ) : array();
				if ( empty( $order_ids ) ) { break; }

				foreach ( $order_ids as $oid ) {
					$order = wc_get_order( $oid );
					if ( ! ( $order instanceof \WC_Order ) ) { continue; }

					foreach ( $order->get_items( 'line_item' ) as $item ) {
						if ( ! ( $item instanceof \WC_Order_Item_Product ) ) { continue; }
						$allocs = $item->get_meta( defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations', true );
						if ( ! is_array( $allocs ) ) { continue; }
						foreach ( $allocs as $row ) {
							$rid    = isset( $row['po_id'] ) ? absint( $row['po_id'] ) : 0;
							$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
							if ( $rid === $po_id && 'released' !== $status ) {
								$out[] = (int) $oid;
								continue 3; // go to next order
							}
						}
					}
				}
				$page++;
			} while ( true );

			return array_values( array_unique( $out ) );
		}

		/**
		 * Recompute final/partial/none for a given order and apply status changes as needed.
		 */
		public static function recompute_for_order( int $order_id ): void {
			if ( $order_id <= 0 || self::$running ) { return; }
			$opt = Status_Auto_Settings::get();
			if ( empty( $opt['enabled'] ) ) { return; }

			$order = function_exists( 'wc_get_order' ) ? wc_get_order( $order_id ) : null;
			if ( ! ( $order instanceof \WC_Order ) ) { return; }

			// fresh per-order cache
			self::$po_received_cache = array();

			self::$running = true;

			try {
				$classification = self::classify_order( $order, $opt['mode'] );
				self::maybe_apply_status( $order, $classification, $opt );
			} catch ( \Throwable $e ) {
				// Fail-safe: never fatal.
			}

			self::$running = false;
		}

		/**
		 * Classify order as 'full', 'partial', or 'none'.
		 *
		 * @param \WC_Order $order
		 * @param string    $mode  'received_based'|'allocated_based'
		 * @return string 'full'|'partial'|'none'
		 */
		protected static function classify_order( \WC_Order $order, string $mode ): string {
			$items = $order->get_items( 'line_item' );
			if ( empty( $items ) ) { return 'none'; }

			$any_considered = false;
			$all_full       = true;
			$any_partial    = false;

			// Per-order consumption guard so we don't double-count PO received pools across this order's own lines.
			$po_usage = array(); // [po_id][target_id] => used_by_this_order

			foreach ( $items as $item ) {
				if ( ! ( $item instanceof \WC_Order_Item_Product ) ) { continue; }
				if ( ! class_exists( __NAMESPACE__ . '\Backorder' ) || ! function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_desired' ) ) { continue; }

				if ( ! Backorder::needs_allocation( $item ) ) { continue; }

				$desired = (int) lpr_allocator_calc_backorder_desired( $item );
				if ( $desired <= 0 ) { continue; }

				$any_considered = true;

				$target_id = (int) ( $item->get_variation_id() ?: $item->get_product_id() );
				if ( $target_id <= 0 ) {
					$all_full = false;
					continue;
				}

				// Received-based coverage for this line.
				$received_for_line = self::received_coverage_for_item( $item, $target_id, $po_usage );

				// Allocation-based coverage if requested.
				$allocated_active = 0;
				if ( function_exists( __NAMESPACE__ . '\lpr_allocator_get_item_allocated_active' ) ) {
					$allocated_active = (int) lpr_allocator_get_item_allocated_active( $item );
				}

				if ( 'received_based' === $mode ) {
					if ( $received_for_line >= $desired ) {
						// fully satisfied by received qty
					} elseif ( $received_for_line > 0 ) {
						$all_full    = false;
						$any_partial = true;
					} else {
						$all_full = false;
					}
				} else { // allocated_based
					if ( $allocated_active >= $desired ) {
						// fully satisfied by allocations
					} elseif ( $allocated_active > 0 ) {
						$all_full    = false;
						$any_partial = true;
					} else {
						$all_full = false;
					}
				}
			}

			if ( ! $any_considered ) {
				return 'none';
			}
			if ( $all_full ) {
				return 'full';
			}
			if ( $any_partial ) {
				return 'partial';
			}
			return 'none';
		}

		/**
		 * Compute "received" coverage for an order item (conservative within the order):
		 * - Gather active allocations for the item grouped by po_id
		 * - For each po_id, look up received pool for the same target product/variation on that PO
		 * - Consume per-PO pool within this order (po_usage) to avoid double counting across lines in the same order
		 */
		protected static function received_coverage_for_item( \WC_Order_Item_Product $item, int $target_id, array &$po_usage ): int {
			$key_allocs = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';
			$allocs     = $item->get_meta( $key_allocs, true );
			if ( ! is_array( $allocs ) ) { return 0; }

			// Sum active allocations by po_id for this item.
			$alloc_by_po = array(); // po_id => qty
			foreach ( $allocs as $row ) {
				$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
				if ( 'released' === $status ) { continue; }
				$po_id = isset( $row['po_id'] ) ? absint( $row['po_id'] ) : 0;
				$qty   = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
				if ( $po_id > 0 && $qty > 0 ) {
					$alloc_by_po[ $po_id ] = ( $alloc_by_po[ $po_id ] ?? 0 ) + $qty;
				}
			}
			if ( empty( $alloc_by_po ) ) { return 0; }

			$covered = 0;
			foreach ( $alloc_by_po as $po_id => $qty_needed_from_po ) {
				$pool = self::po_received_pool_for_target( $po_id, $target_id );
				if ( $pool <= 0 ) { continue; }

				if ( ! isset( $po_usage[ $po_id ] ) ) {
					$po_usage[ $po_id ] = array();
				}
				$used = (int) ( $po_usage[ $po_id ][ $target_id ] ?? 0 );
				$avail_for_this_order = max( 0, $pool - $used );
				if ( $avail_for_this_order <= 0 ) { continue; }

				$take = min( $qty_needed_from_po, $avail_for_this_order );
				$covered += $take;
				$po_usage[ $po_id ][ $target_id ] = $used + $take;
			}

			return max( 0, (int) $covered );
		}

		/**
		 * Lookup total received qty on a PO for a given target product/variation id (cached per request).
		 */
		protected static function po_received_pool_for_target( int $po_id, int $target_id ): int {
			if ( $po_id <= 0 || $target_id <= 0 ) { return 0; }
			if ( isset( self::$po_received_cache[ $po_id ][ $target_id ] ) ) {
				return (int) self::$po_received_cache[ $po_id ][ $target_id ];
			}

			$lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
			$total = 0;
			if ( is_array( $lines ) ) {
				foreach ( $lines as $line ) {
					$line_vid = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
					$line_pid = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
					$line_tid = $line_vid > 0 ? $line_vid : $line_pid;
					if ( $line_tid === $target_id ) {
						$total += isset( $line['qty_received'] ) ? max( 0, (int) $line['qty_received'] ) : 0;
					}
				}
			}

			if ( ! isset( self::$po_received_cache[ $po_id ] ) ) {
				self::$po_received_cache[ $po_id ] = array();
			}
			self::$po_received_cache[ $po_id ][ $target_id ] = (int) $total;

			return (int) $total;
		}

		/**
		 * Apply status change to order based on classification and settings.
		 */
		protected static function maybe_apply_status( \WC_Order $order, string $classification, array $opt ): void {
			$current = $order->get_status(); // bare slug
			$targets = array(
				'full'    => sanitize_key( $opt['status_full'] ?? ORDER_STATUS_READY ),
				'partial' => sanitize_key( $opt['status_partial'] ?? ORDER_STATUS_PARTIAL ),
			);

			// Helper: is current one of our target statuses?
			$is_ours = in_array( $current, array( $targets['full'], $targets['partial'] ), true );

			if ( 'full' === $classification ) {
				$new = $targets['full'];
				if ( $current !== $new ) {
					self::switch_status( $order, $new, sprintf(
						/* translators: 1: mode */
						__( 'Status automation: all backordered items fully satisfied (%s).', 'lpr-backorder-allocator' ),
						( $opt['mode'] === 'allocated_based' ) ? __( 'allocated-based', 'lpr-backorder-allocator' ) : __( 'received-based', 'lpr-backorder-allocator' )
					) );
				}
				return;
			}

			if ( 'partial' === $classification ) {
				$new = $targets['partial'];
				if ( $current !== $new ) {
					self::switch_status( $order, $new, sprintf(
						/* translators: 1: mode */
						__( 'Status automation: some backordered items satisfied (%s).', 'lpr-backorder-allocator' ),
						( $opt['mode'] === 'allocated_based' ) ? __( 'allocated-based', 'lpr-backorder-allocator' ) : __( 'received-based', 'lpr-backorder-allocator' )
					) );
				}
				return;
			}

			// 'none' — if we previously set a custom status, revert to the previous/base status.
			if ( $is_ours ) {
				$prev = sanitize_key( (string) $order->get_meta( ORDER_META_PREV_STATUS, true ) );
				if ( empty( $prev ) ) {
					// Fallback to first configured status from the main settings (usually 'processing').
					$fallback = 'processing';
					if ( class_exists( __NAMESPACE__ . '\Settings' ) ) {
						$st = (array) ( Settings::get()['order_statuses'] ?? array( 'processing', 'on-hold' ) );
						if ( ! empty( $st ) ) {
							$fallback = sanitize_key( preg_replace( '/^wc-/', '', (string) $st[0] ) );
						}
					}
					$prev = $fallback;
				}
				if ( $prev !== $current ) {
					self::switch_status( $order, $prev, __( 'Status automation: reverting — no received/allocated coverage currently.', 'lpr-backorder-allocator' ), true );
				}
			}
		}

		/**
		 * Update order status with a private note and remember previous status for future reverts.
		 *
		 * @param \WC_Order $order
		 * @param string    $new_status Bare slug (e.g., 'processing' or 'lpr-ready-to-ship')
		 * @param string    $note
		 * @param bool      $revert Whether this is a revert (will not overwrite stored previous).
		 */
		protected static function switch_status( \WC_Order $order, string $new_status, string $note, bool $revert = false ): void {
			$current = $order->get_status();
			if ( ! $revert ) {
				// Store previous status once if switching into our automation targets.
				$opt     = Status_Auto_Settings::get();
				$targets = array( sanitize_key( $opt['status_full'] ), sanitize_key( $opt['status_partial'] ) );
				if ( in_array( $new_status, $targets, true ) ) {
					$stored = $order->get_meta( ORDER_META_PREV_STATUS, true );
					if ( empty( $stored ) ) {
						$order->update_meta_data( ORDER_META_PREV_STATUS, $current );
						$order->save();
					}
				}
			}

			// Update status (private note). WC expects bare slug.
			$order->update_status( $new_status, $note, true );
		}
	}
	Order_Status_Automation::init();
}

namespace LPR\Allocator;
if ( ! is_admin() && ! wp_doing_cron() ) { return; }

if ( ! defined( __NAMESPACE__ . '\FRONTEND_POOL_CRON_HOOK' ) ) {
	define( __NAMESPACE__ . '\FRONTEND_POOL_CRON_HOOK', 'lpr_allocator_frontend_pool_cron' );
}

if ( ! class_exists( __NAMESPACE__ . '\Frontend_Extra_Pool_Writer' ) ) {
	/**
	 * Batch 8 — Extra Incoming Meta Writer for Frontend (unallocated pool + next ETA)
	 *
	 * Maintains fast-to-read product meta:
	 *  - _lpr_unallocated_pool (int)
	 *  - _lpr_next_extra_qty  (int)
	 *  - _lpr_next_extra_eta  (Y-m-d)
	 *
	 * Triggers:
	 *  - On Supplier PO save (only products from that PO are recomputed)
	 *  - After allocations (Action Scheduler job and inline fallback)
	 *  - Nightly cron safety sweep
	 *
	 * No stock writes. HPOS/CRUD safe. No wildcard meta queries.
	 */
	class Frontend_Extra_Pool_Writer {

		/** Re-entrancy guard. */
		protected static $running = false;

		public static function init(): void {
			// Recompute when a Supplier PO is saved (after its meta is persisted).
			add_action( 'save_post', array( __CLASS__, 'on_po_saved' ), 100, 2 );

			// After allocations via Action Scheduler (PO_FIFO_Allocator hooks at priority 10).
			add_action( 'lpr_allocator_allocate_po', array( __CLASS__, 'on_allocation_job' ), 20, 1 );

			// Inline allocation fallback: after redirect with lpr_alloc=done on PO edit screen.
			add_action( 'load-post.php', array( __CLASS__, 'on_po_edit_after_allocate' ) );

			// Nightly cron (AS preferred, WP-Cron fallback).
			add_action( 'admin_init', array( __CLASS__, 'maybe_schedule' ) );
			add_action( FRONTEND_POOL_CRON_HOOK, array( __CLASS__, 'run_cron' ) );
		}

		/**
		 * Supplier PO saved → recompute only products that appear in this PO.
		 */
		public static function on_po_saved( int $post_id, $post ): void {
			if ( self::$running ) { return; }
			if ( defined( 'DOING_AUTOSAVE' ) && DOING_AUTOSAVE ) { return; }
			if ( wp_is_post_revision( $post_id ) ) { return; }
			if ( ! ( $post instanceof \WP_Post ) ) { return; }
			if ( ! defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ) { return; }
			if ( $post->post_type !== CPT_SUPPLIER_PO ) { return; }

			self::recompute_for_po( (int) $post_id );
		}

		/**
		 * Allocation job completed (AS path) → recompute products on that PO.
		 */
		public static function on_allocation_job( $po_id ): void {
			if ( self::$running ) { return; }
			$pid = (int) $po_id;
			if ( $pid <= 0 ) { return; }
			self::recompute_for_po( $pid );
		}

		/**
		 * Inline allocation fallback: after redirect, detect lpr_alloc=done on PO edit page.
		 */
		public static function on_po_edit_after_allocate(): void {
			if ( self::$running ) { return; }
			if ( empty( $_GET['lpr_alloc'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification.Recommended
				return;
			}
			$state = sanitize_key( wp_unslash( $_GET['lpr_alloc'] ) ); // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			if ( 'done' !== $state ) {
				return; // queued path will be handled by the AS hook when it actually runs
			}
			$po_id = isset( $_GET['post'] ) ? absint( $_GET['post'] ) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended
			if ( $po_id <= 0 ) { return; }
			$post = get_post( $po_id );
			if ( ! ( $post instanceof \WP_Post ) ) { return; }
			if ( ! defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) || $post->post_type !== CPT_SUPPLIER_PO ) {
				return;
			}
			self::recompute_for_po( (int) $po_id );
		}

		/**
		 * Cron scheduler.
		 */
		public static function maybe_schedule(): void {
			if ( function_exists( 'as_has_scheduled_action' ) && function_exists( 'as_schedule_recurring_action' ) ) {
				if ( ! as_has_scheduled_action( FRONTEND_POOL_CRON_HOOK, array(), 'lpr-allocator' ) ) {
					as_schedule_recurring_action( time() + HOUR_IN_SECONDS, DAY_IN_SECONDS, FRONTEND_POOL_CRON_HOOK, array(), 'lpr-allocator' );
				}
			} else {
				if ( function_exists( 'wp_next_scheduled' ) && ! wp_next_scheduled( FRONTEND_POOL_CRON_HOOK ) ) {
					wp_schedule_event( time() + HOUR_IN_SECONDS, 'daily', FRONTEND_POOL_CRON_HOOK );
				}
			}
		}

		/**
		 * Nightly safety sweep: rebuild for all targets on open/partial POs.
		 */
		public static function run_cron(): void {
			if ( self::$running ) { return; }
			self::$running = true;
			try {
				self::rebuild_all();
			} catch ( \Throwable $e ) {
				// Silent fail-safe.
			}
			self::$running = false;
		}

		/**
		 * Recompute meta for products that appear on a specific PO.
		 */
		protected static function recompute_for_po( int $po_id ): void {
			if ( $po_id <= 0 ) { return; }
			$targets = self::extract_target_ids_from_po( $po_id );
			if ( empty( $targets ) ) { return; }

			$agg = self::aggregate_from_open_partial_pos( $targets );

			// Ensure we write zeros for any targets that currently have no remaining lines.
			foreach ( $targets as $tid ) {
				if ( ! isset( $agg[ $tid ] ) ) {
					$agg[ $tid ] = array( 'unallocated' => 0, 'next_eta' => '', 'next_qty' => 0 );
				}
			}
			self::write_results( $agg );
		}

		/**
		 * Full rebuild across all open/partial POs (cron).
		 */
		protected static function rebuild_all(): void {
			$agg = self::aggregate_from_open_partial_pos( null );
			if ( ! empty( $agg ) ) {
				self::write_results( $agg );
			}
		}

		/**
		 * Extract unique product/variation IDs from a single PO.
		 *
		 * @return int[]
		 */
		protected static function extract_target_ids_from_po( int $po_id ): array {
			$key_lines = defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines';
			$lines     = get_post_meta( $po_id, $key_lines, true );
			$ids_map   = array();

			if ( is_array( $lines ) ) {
				foreach ( $lines as $line ) {
					$vid = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
					$pid = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
					$tid = $vid > 0 ? $vid : $pid;
					if ( $tid > 0 ) {
						$ids_map[ $tid ] = true;
					}
				}
			}
			return array_map( 'intval', array_keys( $ids_map ) );
		}

		/**
		 * Aggregate remaining incoming pools across all open/partial POs.
		 *
		 * If $only_targets is provided, we compute only for that set; still scanning open/partial POs.
		 *
		 * @param int[]|null $only_targets
		 * @return array target_id => ['unallocated' => int, 'next_eta' => 'Y-m-d'|'', 'next_qty' => int]
		 */
		protected static function aggregate_from_open_partial_pos( ?array $only_targets ): array {
			$want = null;
			if ( is_array( $only_targets ) && ! empty( $only_targets ) ) {
				$want = array_fill_keys( array_map( 'intval', $only_targets ), true );
			}

			$agg = array();

			$post_type = defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) ? CPT_SUPPLIER_PO : 'supplier_po';
			$statuses  = array();
			$statuses[] = defined( __NAMESPACE__ . '\PO_STATUS_OPEN' ) ? PO_STATUS_OPEN : 'open';
			$statuses[] = defined( __NAMESPACE__ . '\PO_STATUS_PARTIAL' ) ? PO_STATUS_PARTIAL : 'partial';

			$page  = 1;
			$limit = 50;

			do {
				$q = new \WP_Query(
					array(
						'post_type'      => $post_type,
						'post_status'    => $statuses,
						'posts_per_page' => $limit,
						'paged'          => $page,
						'orderby'        => 'ID',
						'order'          => 'DESC',
						'fields'         => 'ids',
						'no_found_rows'  => true,
					)
				);
				if ( ! $q->have_posts() ) {
					wp_reset_postdata();
					break;
				}

				foreach ( $q->posts as $po_id ) {
					$key_eta   = defined( __NAMESPACE__ . '\PO_META_ETA_DATE' ) ? PO_META_ETA_DATE : '_lpr_eta_date';
					$key_lines = defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines';

					$po_eta_default = self::sanitize_ymd( get_post_meta( $po_id, $key_eta, true ) );
					$lines          = get_post_meta( $po_id, $key_lines, true );

					if ( ! is_array( $lines ) ) {
						continue;
					}

					foreach ( $lines as $line ) {
						$vid = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
						$pid = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
						$tid = $vid > 0 ? $vid : $pid;
						if ( $tid <= 0 ) { continue; }
						if ( null !== $want && empty( $want[ $tid ] ) ) { continue; }

						$ordered  = isset( $line['qty_ordered'] ) ? max( 0, (int) $line['qty_ordered'] ) : 0;
						$allocated= isset( $line['qty_allocated'] ) ? max( 0, (int) $line['qty_allocated'] ) : 0;
						$received = isset( $line['qty_received'] ) ? max( 0, (int) $line['qty_received'] ) : 0;
						$remaining = max( 0, $ordered - $allocated - $received );
						if ( $remaining <= 0 ) { continue; }

						$eta = '';
						if ( ! empty( $line['eta_override'] ) ) {
							$eta = self::sanitize_ymd( $line['eta_override'] );
						}
						if ( '' === $eta ) {
							$eta = $po_eta_default;
						}

						if ( ! isset( $agg[ $tid ] ) ) {
							$agg[ $tid ] = array(
								'unallocated' => 0,
								'next_eta'    => '',
								'next_qty'    => 0,
							);
						}

						$agg[ $tid ]['unallocated'] += $remaining;

						// Earliest ETA and the sum of remaining on that earliest date.
						if ( '' !== $eta ) {
							if ( '' === $agg[ $tid ]['next_eta'] || strcmp( $eta, $agg[ $tid ]['next_eta'] ) < 0 ) {
								$agg[ $tid ]['next_eta'] = $eta;
								$agg[ $tid ]['next_qty'] = $remaining;
							} elseif ( $eta === $agg[ $tid ]['next_eta'] ) {
								$agg[ $tid ]['next_qty'] += $remaining;
							}
						}
					}
				}

				wp_reset_postdata();
				$page++;
			} while ( true );

			return $agg;
		}

		/**
		 * Persist computed pools to product/variation meta.
		 */
		protected static function write_results( array $agg ): void {
			$key_pool = defined( __NAMESPACE__ . '\PRODUCT_META_UNALLOCATED_POOL' ) ? PRODUCT_META_UNALLOCATED_POOL : '_lpr_unallocated_pool';
			$key_qty  = defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_QTY' ) ? PRODUCT_META_NEXT_EXTRA_QTY : '_lpr_next_extra_qty';
			$key_eta  = defined( __NAMESPACE__ . '\PRODUCT_META_NEXT_EXTRA_ETA' ) ? PRODUCT_META_NEXT_EXTRA_ETA : '_lpr_next_extra_eta';

			foreach ( $agg as $tid => $row ) {
				$tid       = (int) $tid;
				$unalloc   = max( 0, (int) ( $row['unallocated'] ?? 0 ) );
				$next_qty  = max( 0, (int) ( $row['next_qty'] ?? 0 ) );
				$next_eta  = (string) ( $row['next_eta'] ?? '' );

				update_post_meta( $tid, $key_pool, $unalloc );
				update_post_meta( $tid, $key_qty,  $next_qty );
				update_post_meta( $tid, $key_eta,  $next_eta );
			}
		}

		/**
		 * Safe Y-m-d sanitizer using the existing helper when available.
		 */
		protected static function sanitize_ymd( $val ): string {
			$val = (string) $val;
			if ( function_exists( __NAMESPACE__ . '\lpr_allocator_sanitize_ymd' ) ) {
				return lpr_allocator_sanitize_ymd( $val );
			}
			$val = trim( $val );
			return ( preg_match( '/^\d{4}-\d{2}-\d{2}$/', $val ) ) ? $val : '';
		}
	}

	Frontend_Extra_Pool_Writer::init();
}

namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() ) { return; }

if ( ! class_exists( __NAMESPACE__ . '\PO_Reconciler' ) ) {
	class PO_Reconciler {

		protected static function release_overflow_for_po( int $po_id ): void {
	if ( $po_id <= 0 || ! function_exists( 'wc_get_orders' ) ) {
		return;
	}

	// Per-PO lock (short) to avoid double processing.
	$lock_key = 'lpr_reconcile_lock_po_' . (int) $po_id;
	if ( get_transient( $lock_key ) ) {
		return;
	}
	set_transient( $lock_key, 1, 60 );

	try {
		$key_lines = defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines';
		$lines     = get_post_meta( $po_id, $key_lines, true );
		if ( ! is_array( $lines ) || empty( $lines ) ) {
			return;
		}

		// 1) Allowed capacity per target on this PO = sum of qty_ordered across all lines.
		$allowed_by_target = array();
		foreach ( $lines as $line ) {
			$vid = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
			$pid = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
			$tid = $vid > 0 ? $vid : $pid;
			if ( $tid <= 0 ) { continue; }
			$allowed_by_target[ $tid ] = ( $allowed_by_target[ $tid ] ?? 0 ) + max( 0, (int) ( $line['qty_ordered'] ?? 0 ) );
		}
		if ( empty( $allowed_by_target ) ) {
			return;
		}

		// Build statuses to scan: settings + our custom automation statuses.
		$statuses = array();
		$settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
		foreach ( (array) ( $settings['order_statuses'] ?? array() ) as $st ) {
			$statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
		}
		if ( defined( __NAMESPACE__ . '\ORDER_STATUS_READY' ) )   { $statuses[] = 'wc-' . ORDER_STATUS_READY; }
		if ( defined( __NAMESPACE__ . '\ORDER_STATUS_PARTIAL' ) ) { $statuses[] = 'wc-' . ORDER_STATUS_PARTIAL; }
		$statuses = array_values( array_unique( $statuses ) );

		$key_allocs = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';

		// 2) Collect active allocation rows referencing this PO, grouped by target.
		$rows_by_target = array(); // tid => [ [order, order_id, item, item_id, idx, qty, eta, po_number, ts], ... ]
		$page = 1; $limit = 50;
		do {
			$args = array(
				'status'  => $statuses,
				'limit'   => $limit,
				'page'    => $page,
				'orderby' => 'date',
				'order'   => 'ASC',
				'return'  => 'ids',
				'type'    => 'shop_order',
			);
			$order_ids = wc_get_orders( $args );
			if ( empty( $order_ids ) ) { break; }

			foreach ( $order_ids as $oid ) {
				$order = wc_get_order( $oid );
				if ( ! ( $order instanceof \WC_Order ) ) { continue; }

				$paid_ts    = $order->get_date_paid()    ? (int) $order->get_date_paid()->getTimestamp()    : null;
				$created_ts = $order->get_date_created() ? (int) $order->get_date_created()->getTimestamp() : 0;

				foreach ( $order->get_items( 'line_item' ) as $item ) {
					if ( ! ( $item instanceof \WC_Order_Item_Product ) ) { continue; }
					$tid = (int) ( $item->get_variation_id() ?: $item->get_product_id() );
					if ( $tid <= 0 || empty( $allowed_by_target[ $tid ] ) ) { continue; }

					$allocs = $item->get_meta( $key_allocs, true );
					if ( ! is_array( $allocs ) || empty( $allocs ) ) { continue; }

					foreach ( $allocs as $idx => $row ) {
						$rid    = isset( $row['po_id'] ) ? absint( $row['po_id'] ) : 0;
						$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
						$q      = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
						if ( $rid !== $po_id || $q <= 0 || 'released' === $status ) {
							continue;
						}

						$ts = 0;
						if ( ! empty( $row['allocated_at'] ) ) {
							$ts = strtotime( (string) $row['allocated_at'] ) ?: 0;
						}
						if ( ! $ts ) {
							$ts = $paid_ts ?? $created_ts; // fallback if old rows lack allocated_at
						}

						$rows_by_target[ $tid ][] = array(
							'order'      => $order,
							'order_id'   => (int) $oid,
							'item'       => $item,
							'item_id'    => (int) $item->get_id(),
							'idx'        => (int) $idx,
							'qty'        => (int) $q,
							'eta'        => (string) ( $row['eta'] ?? '' ),
							'po_number'  => (string) ( $row['po_number'] ?? '' ),
							'ts'         => (int) $ts,
						);
					}
				}
			}

			$page++;
		} while ( true );

		if ( empty( $rows_by_target ) ) {
			return;
		}

		// 3) For each target: if active > allowed → release newest rows until under cap.
		$orders_changed = array();

		foreach ( $allowed_by_target as $tid => $allowed ) {
			$rows = $rows_by_target[ $tid ] ?? array();
			if ( empty( $rows ) ) { continue; }

			$active = 0;
			foreach ( $rows as $r ) { $active += (int) $r['qty']; }
			$overflow = max( 0, (int) ( $active - $allowed ) );
			if ( $overflow <= 0 ) { continue; }

			// Newest-first (LIFO) to keep FIFO fairness for customers who ordered earlier.
			usort( $rows, static function( $a, $b ) {
				return (int) $b['ts'] <=> (int) $a['ts'];
			} );

			foreach ( $rows as $r ) {
				if ( $overflow <= 0 ) { break; }

				/** @var \WC_Order_Item_Product $item */
				$item   = $r['item'];
				$allocs = $item->get_meta( $key_allocs, true );
				if ( ! is_array( $allocs ) || ! isset( $allocs[ $r['idx'] ] ) ) { continue; }

				$have = max( 0, (int) ( $allocs[ $r['idx'] ]['qty_allocated'] ?? 0 ) );
				if ( $have <= 0 ) { continue; }

				$take = min( $have, $overflow );
				$allocs[ $r['idx'] ]['qty_allocated'] = max( 0, $have - $take );

				// Append released audit row.
				$allocs[] = array(
					'po_id'         => (int) $po_id,
					'po_number'     => (string) $r['po_number'],
					'qty_allocated' => (int) $take,
					'eta'           => (string) $r['eta'],
					'status'        => 'released',
					'released_at'   => current_time( 'mysql' ),
				);

				$item->update_meta_data( $key_allocs, $allocs );
				$item->save();

				// Order note (concise).
				$r['order']->add_order_note(
					sprintf(
						/* translators: 1: qty */
						__( 'Allocation reduced by %1$d due to PO quantity change.', 'lpr-backorder-allocator' ),
						(int) $take
					),
					false,
					true
				);

				$orders_changed[ (int) $r['order_id'] ] = true;
				$overflow -= $take;
			}
		}

		// Refresh ETAs for affected orders.
		if ( ! empty( $orders_changed ) && class_exists( __NAMESPACE__ . '\ETA' ) ) {
			foreach ( array_keys( $orders_changed ) as $oid ) {
				ETA::update_line_eta( (int) $oid );
			}
		}
	} finally {
		delete_transient( $lock_key );
	}
}

		public static function init(): void {
			// After PO save (late, so meta is persisted).
			add_action( 'save_post', array( __CLASS__, 'on_po_saved' ), 200, 2 );
			// After allocation job finishes.
			add_action( 'lpr_allocator_allocate_po', array( __CLASS__, 'resync' ), 30, 1 );
		}

		public static function on_po_saved( int $post_id, $post ): void {
			if ( defined( 'DOING_AUTOSAVE' ) && DOING_AUTOSAVE ) { return; }
			if ( wp_is_post_revision( $post_id ) ) { return; }
			if ( ! ( $post instanceof \WP_Post ) ) { return; }
			if ( ! defined( __NAMESPACE__ . '\CPT_SUPPLIER_PO' ) || $post->post_type !== CPT_SUPPLIER_PO ) { return; }
			self::resync( (int) $post_id );
		}

		public static function resync( int $po_id ): void {
					// NEW: release any overflow allocations if PO qty was decreased
		if ( method_exists( __CLASS__, 'release_overflow_for_po' ) ) {
			self::release_overflow_for_po( $po_id );
		}

			if ( $po_id <= 0 || ! function_exists( 'wc_get_orders' ) ) { return; }

			$lines = get_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', true );
			if ( ! is_array( $lines ) || empty( $lines ) ) { return; }

			// Map targets from PO lines.
			$targets = array(); // target_id => index(es)
			foreach ( $lines as $idx => $line ) {
				$vid = isset( $line['variation_id'] ) ? absint( $line['variation_id'] ) : 0;
				$pid = isset( $line['product_id'] ) ? absint( $line['product_id'] ) : 0;
				$tid = $vid > 0 ? $vid : $pid;
				if ( $tid > 0 ) {
					if ( ! isset( $targets[ $tid ] ) ) { $targets[ $tid ] = array(); }
					$targets[ $tid ][] = $idx;
				}
			}
			if ( empty( $targets ) ) { return; }

			// Build statuses from settings (bare -> wc-)
			$settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
			$statuses = array();
			foreach ( (array) $settings['order_statuses'] as $st ) {
				$statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
			}

			// Sum active allocations per target_id for this PO.
			$sum_by_target = array();
			$page = 1; $limit = 50;
			$key_allocs = defined( __NAMESPACE__ . '\ORDER_ITEM_META_ALLOCATIONS' ) ? ORDER_ITEM_META_ALLOCATIONS : 'lpr_allocations';

			do {
				$args = array(
					'status'  => $statuses,
					'limit'   => $limit,
					'page'    => $page,
					'orderby' => 'date',
					'order'   => 'ASC',
					'return'  => 'ids',
					'type'    => 'shop_order',
				);
				$order_ids = wc_get_orders( $args );
				if ( empty( $order_ids ) ) { break; }

				foreach ( $order_ids as $oid ) {
					$order = wc_get_order( $oid );
					if ( ! ( $order instanceof \WC_Order ) ) { continue; }
					foreach ( $order->get_items( 'line_item' ) as $item ) {
						if ( ! ( $item instanceof \WC_Order_Item_Product ) ) { continue; }
						$tid = (int) ( $item->get_variation_id() ?: $item->get_product_id() );
						if ( $tid <= 0 || empty( $targets[ $tid ] ) ) { continue; }

						$allocs = $item->get_meta( $key_allocs, true );
						if ( ! is_array( $allocs ) ) { continue; }
						foreach ( $allocs as $row ) {
							$rid    = isset( $row['po_id'] ) ? absint( $row['po_id'] ) : 0;
							$status = isset( $row['status'] ) ? sanitize_key( (string) $row['status'] ) : 'reserved';
							$q      = isset( $row['qty_allocated'] ) ? max( 0, (int) $row['qty_allocated'] ) : 0;
							if ( $rid === $po_id && 'released' !== $status && $q > 0 ) {
								$sum_by_target[ $tid ] = ( $sum_by_target[ $tid ] ?? 0 ) + $q;
							}
						}
					}
				}

				$page++;
			} while ( true );

			// Update PO lines qty_allocated from the sums (clamped to ordered)
			$changed = false;
			foreach ( $targets as $tid => $idxes ) {
				$sum = (int) ( $sum_by_target[ $tid ] ?? 0 );
				foreach ( $idxes as $idx ) {
					$ordered = isset( $lines[ $idx ]['qty_ordered'] ) ? max( 0, (int) $lines[ $idx ]['qty_ordered'] ) : 0;
					$new     = min( $ordered, $sum );
					$old     = isset( $lines[ $idx ]['qty_allocated'] ) ? max( 0, (int) $lines[ $idx ]['qty_allocated'] ) : 0;
					if ( $new !== $old ) {
						$lines[ $idx ]['qty_allocated'] = $new;
						$changed = true;
					}
				}
			}
			if ( $changed ) {
				update_post_meta( $po_id, defined( __NAMESPACE__ . '\PO_META_LINES' ) ? PO_META_LINES : '_lpr_po_lines', $lines );
			}
		}
	}
	PO_Reconciler::init();
}
namespace LPR\Allocator;

if ( ! is_admin() && ! wp_doing_cron() ) { return; }

/**
 * -------------------------------------------------------------------------
 * Backorder Orders Overview (admin page + cached snapshot)
 * -------------------------------------------------------------------------
 * - Shows ALL orders with at least one backordered line (statuses from Settings)
 * - Displays every product on such orders and highlights backordered/unallocated lines
 * - Per-line ETA comes ONLY from that line's allocations (no cross-order bleed)
 * - Order ETA = latest line ETA across backordered lines, or blank if any are unallocated
 * - Includes Total order value
 * - Uses a precomputed snapshot (autoload=no) for instant rendering
 */
if ( ! defined( __NAMESPACE__ . '\ORDERS_SNAPSHOT_OPT' ) ) {
	define( __NAMESPACE__ . '\ORDERS_SNAPSHOT_OPT', 'lpr_allocator_orders_snapshot' );
}
if ( ! defined( __NAMESPACE__ . '\ORDERS_SNAPSHOT_CRON_HOOK' ) ) {
	define( __NAMESPACE__ . '\ORDERS_SNAPSHOT_CRON_HOOK', 'lpr_allocator_build_orders_snapshot' );
}

if ( ! class_exists( __NAMESPACE__ . '\Backorder_Orders_Snapshot' ) ) {
	class Backorder_Orders_Snapshot {

		/** Snapshot is considered stale after N seconds. */
		const MAX_AGE = 600; // 10 minutes

		public static function init(): void {
			add_action( 'admin_init', array( __CLASS__, 'ensure_option_and_warm' ) );
			add_action( 'admin_post_lpr_build_orders_snapshot', array( __CLASS__, 'handle_rebuild' ) );
			// Nightly rebuild if Action Scheduler or WP-Cron available.
			add_action( ORDERS_SNAPSHOT_CRON_HOOK, array( __CLASS__, 'build_and_store' ) );
			add_action( 'admin_init', array( __CLASS__, 'maybe_schedule_nightly' ) );
		}

		public static function ensure_option_and_warm(): void {
			if ( null === get_option( ORDERS_SNAPSHOT_OPT, null ) ) {
				add_option( ORDERS_SNAPSHOT_OPT, array( 'built_at' => 0, 'orders' => array() ), '', 'no' );
				// Warm it once in the background if we can.
				if ( function_exists( 'as_enqueue_async_action' ) ) {
					as_enqueue_async_action( ORDERS_SNAPSHOT_CRON_HOOK, array(), 'lpr-allocator' );
				} else {
					// Best-effort inline (first page or two) to avoid empty first render.
					self::build_and_store( true );
				}
			}
		}

		public static function maybe_schedule_nightly(): void {
			// Prefer Action Scheduler
			if ( function_exists( 'as_has_scheduled_action' ) && function_exists( 'as_schedule_recurring_action' ) ) {
				if ( ! as_has_scheduled_action( ORDERS_SNAPSHOT_CRON_HOOK, array(), 'lpr-allocator' ) ) {
					as_schedule_recurring_action( time() + HOUR_IN_SECONDS, DAY_IN_SECONDS, ORDERS_SNAPSHOT_CRON_HOOK, array(), 'lpr-allocator' );
				}
				return;
			}
			// Fallback to WP-Cron daily
			if ( function_exists( 'wp_next_scheduled' ) && ! wp_next_scheduled( ORDERS_SNAPSHOT_CRON_HOOK ) ) {
				wp_schedule_event( time() + HOUR_IN_SECONDS, 'daily', ORDERS_SNAPSHOT_CRON_HOOK );
			}
		}

		public static function handle_rebuild(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				wp_die( esc_html__( 'Insufficient permissions.', 'lpr-backorder-allocator' ) );
			}
			$nonce = isset( $_GET['_wpnonce'] ) ? (string) $_GET['_wpnonce'] : ''; // phpcs:ignore
			if ( ! wp_verify_nonce( $nonce, 'lpr_build_orders_snapshot' ) ) {
				wp_die( esc_html__( 'Invalid request.', 'lpr-backorder-allocator' ) );
			}
			$redirect = admin_url( 'admin.php?page=lpr-backorder-orders' );

			$queued = false;
			if ( function_exists( 'as_enqueue_async_action' ) ) {
				as_enqueue_async_action( ORDERS_SNAPSHOT_CRON_HOOK, array(), 'lpr-allocator' );
				$queued = true;
			} elseif ( function_exists( 'as_schedule_single_action' ) ) {
				as_schedule_single_action( time(), ORDERS_SNAPSHOT_CRON_HOOK, array(), 'lpr-allocator' );
				$queued = true;
			} else {
				self::build_and_store( false );
			}

			wp_safe_redirect( add_query_arg( array( 'lpr_snapshot' => $queued ? 'queued' : 'rebuilt' ), $redirect ) );
			exit;
		}

		/**
		 * Get snapshot (and opportunistically queue rebuild if stale).
		 */
		public static function get( bool $allow_stale = true ): array {
			$shot = get_option( ORDERS_SNAPSHOT_OPT, array( 'built_at' => 0, 'orders' => array() ) );
			if ( ! is_array( $shot ) || ! isset( $shot['orders'] ) ) {
				$shot = array( 'built_at' => 0, 'orders' => array() );
			}
			if ( ! $allow_stale ) {
				$stale = ( time() - (int) $shot['built_at'] ) > self::MAX_AGE;
				if ( $stale && function_exists( 'as_enqueue_async_action' ) ) {
					as_enqueue_async_action( ORDERS_SNAPSHOT_CRON_HOOK, array(), 'lpr-allocator' );
				}
			}
			return $shot;
		}

		/**
		 * Build and store the snapshot.
		 *
		 * @param bool $shallow  If true, scans just a small initial window (for first warmup).
		 */
		public static function build_and_store( bool $shallow = false ): void {
			$shot = self::build_snapshot( $shallow );
			$existing = get_option( ORDERS_SNAPSHOT_OPT, null );
			if ( null === $existing ) {
				add_option( ORDERS_SNAPSHOT_OPT, $shot, '', 'no' );
			} else {
				update_option( ORDERS_SNAPSHOT_OPT, $shot, false );
			}
		}

		protected static function statuses_to_scan(): array {
			$settings = class_exists( __NAMESPACE__ . '\Settings' ) ? Settings::get() : array( 'order_statuses' => array( 'processing', 'on-hold' ) );
			$statuses = array();
			foreach ( (array) ( $settings['order_statuses'] ?? array() ) as $st ) {
				$statuses[] = 'wc-' . preg_replace( '/^wc-/', '', sanitize_key( $st ) );
			}
			// Include our automation statuses if registered.
			if ( defined( __NAMESPACE__ . '\ORDER_STATUS_READY' ) )   { $statuses[] = 'wc-' . ORDER_STATUS_READY; }
			if ( defined( __NAMESPACE__ . '\ORDER_STATUS_PARTIAL' ) ) { $statuses[] = 'wc-' . ORDER_STATUS_PARTIAL; }
			return array_values( array_unique( $statuses ) );
		}

protected static function build_snapshot( bool $shallow ): array {
	if ( ! function_exists( 'wc_get_orders' ) ) {
		return array( 'built_at' => time(), 'orders' => array() );
	}

	$orders_out  = array();
	$statuses    = self::statuses_to_scan();
	$page        = 1;
	$limit       = 50;
	$max_pages   = $shallow ? 2 : 100000; // practically "all"
	$pages_scanned = 0;

	do {
		$args = array(
			'status'  => $statuses,
			'limit'   => $limit,
			'page'    => $page,
			'orderby' => 'date',
			'order'   => 'ASC',
			'return'  => 'ids',
			'type'    => 'shop_order',
		);

		$order_ids = wc_get_orders( $args );
		if ( empty( $order_ids ) ) {
			break;
		}

		foreach ( $order_ids as $oid ) {
			$order = wc_get_order( $oid );
			if ( ! ( $order instanceof \WC_Order ) ) { continue; }

			$items = $order->get_items( 'line_item' );
			if ( empty( $items ) ) { continue; }

			$order_row = array(
				'order_id'       => (int) $order->get_id(),
				'order_number'   => (string) ( method_exists( $order, 'get_order_number' ) ? $order->get_order_number() : $order->get_id() ),
				'status'         => (string) $order->get_status(),
				'created'        => (string) ( $order->get_date_created() ? $order->get_date_created()->date( 'Y-m-d H:i' ) : '' ),
				'currency'       => (string) $order->get_currency(),
				'total'          => (float)  $order->get_total(),
				'customer_name'  => (string) ( trim( $order->get_formatted_billing_full_name() ) ?: trim( $order->get_billing_first_name() . ' ' . $order->get_billing_last_name() ) ?: __( 'Guest', 'lpr-backorder-allocator' ) ),
				'customer_email' => (string) $order->get_billing_email(),
				'items'          => array(), // filled below
				'has_backorder'  => false,
				'has_unallocated'=> false,   // set when any backordered line has unmet need (>0)
				'order_eta'      => '',      // computed below
			);

			$line_etas = array();

			foreach ( $items as $item ) {
				if ( ! ( $item instanceof \WC_Order_Item_Product ) ) { continue; }

				$product = $item->get_product();
				$sku     = $product instanceof \WC_Product ? (string) $product->get_sku() : '';
				$qty     = (int) $item->get_quantity();

				// Backorder / allocation figures.
				$desired   = function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_desired' ) ? (int) lpr_allocator_calc_backorder_desired( $item ) : 0;
				$allocated = function_exists( __NAMESPACE__ . '\lpr_allocator_get_item_allocated_active' ) ? (int) lpr_allocator_get_item_allocated_active( $item ) : 0;
				$need      = function_exists( __NAMESPACE__ . '\lpr_allocator_calc_backorder_need' ) ? (int) lpr_allocator_calc_backorder_need( $item ) : max( 0, $desired - $allocated );

				$is_backordered = ( $desired > 0 );
				$is_partial     = ( $is_backordered && $allocated > 0 && $need > 0 );
				$is_unallocated = ( $is_backordered && $allocated <= 0 && $need > 0 );

				// Per-line ETA must come from an actual allocation. If nothing is allocated, ignore any meta.
				$line_eta_key = defined( __NAMESPACE__ . '\ORDER_ITEM_META_LINE_ETA' ) ? ORDER_ITEM_META_LINE_ETA : '_lpr_line_eta';
				$line_eta_raw = (string) $item->get_meta( $line_eta_key, true );
				$line_eta     = '';
				if ( $allocated > 0 && $line_eta_raw && preg_match( '/^\d{4}-\d{2}-\d{2}$/', $line_eta_raw ) ) {
					$line_eta = $line_eta_raw;
				}

				// Order-level flags and order-level ETA candidates.
				if ( $is_backordered ) {
					$order_row['has_backorder'] = true;

					// Any unmet need (including partials) means the order is still "unallocated" in the sense of promising a date.
					if ( $need > 0 ) {
						$order_row['has_unallocated'] = true;
					}

					// Only include line ETA in the pool if it is truly allocation-derived.
					if ( '' !== $line_eta ) {
						$line_etas[] = $line_eta;
					}
				}

				$order_row['items'][] = array(
					'name'           => (string) $item->get_name(),
					'sku'            => $sku,
					'qty'            => (int) $qty,
					'desired'        => (int) $desired,
					'allocated'      => (int) $allocated,
					'need'           => (int) $need,
					'line_eta'       => (string) $line_eta, // blank when not allocated
					'is_backordered' => (bool) $is_backordered,
					'is_unallocated' => (bool) $is_unallocated,
					'is_partial'     => (bool) $is_partial,
				);
			}

			// Only include orders that actually have backordered items.
			if ( ! $order_row['has_backorder'] ) {
				continue;
			}

			// Order ETA = latest allocation-derived line ETA across backordered lines,
			// but only if there is NO unmet need anywhere on the order.
			if ( ! $order_row['has_unallocated'] && ! empty( $line_etas ) ) {
				sort( $line_etas, SORT_STRING ); // Y-m-d sortable as strings
				$order_row['order_eta'] = (string) end( $line_etas ); // max
			}

			$orders_out[] = $order_row;
		}

		$page++;
		$pages_scanned++;
	} while ( $pages_scanned < $max_pages );

	return array(
		'built_at' => time(),
		'orders'   => $orders_out,
	);
}
	}
	Backorder_Orders_Snapshot::init();
}

if ( ! class_exists( __NAMESPACE__ . '\Backorder_Orders_Page' ) ) {
	class Backorder_Orders_Page {

		public static function init(): void {
			add_action( 'admin_menu', array( __CLASS__, 'register_page' ) );
			add_action( 'admin_notices', array( __CLASS__, 'maybe_notice' ) );
		}

		public static function register_page(): void {
			add_submenu_page(
				'woocommerce',
				__( 'Backorder Orders', 'lpr-backorder-allocator' ),
				__( 'Backorder Orders', 'lpr-backorder-allocator' ),
				'manage_woocommerce',
				'lpr-backorder-orders',
				array( __CLASS__, 'render' )
			);
		}

		public static function maybe_notice(): void {
			if ( ! isset( $_GET['lpr_snapshot'] ) ) { // phpcs:ignore
				return;
			}
			$state = sanitize_key( wp_unslash( $_GET['lpr_snapshot'] ) ); // phpcs:ignore
			if ( 'queued' === $state ) {
				echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'Snapshot rebuild queued. It will process shortly.', 'lpr-backorder-allocator' ) . '</p></div>';
			} elseif ( 'rebuilt' === $state ) {
				echo '<div class="notice notice-success is-dismissible"><p>' . esc_html__( 'Snapshot rebuilt.', 'lpr-backorder-allocator' ) . '</p></div>';
			}
		}

		public static function render(): void {
			if ( ! current_user_can( 'manage_woocommerce' ) ) {
				return;
			}
			$shot     = Backorder_Orders_Snapshot::get( false );
			$built_ts = isset( $shot['built_at'] ) ? (int) $shot['built_at'] : 0;
			$orders   = isset( $shot['orders'] ) && is_array( $shot['orders'] ) ? $shot['orders'] : array();

			$rebuild_url = wp_nonce_url(
				add_query_arg(
					array( 'action' => 'lpr_build_orders_snapshot' ),
					admin_url( 'admin-post.php' )
				),
				'lpr_build_orders_snapshot'
			);

			?>
			<div class="wrap">
				<h1><?php echo esc_html__( 'Backorder Orders', 'lpr-backorder-allocator' ); ?></h1>

				<div style="margin:10px 0; display:flex; gap:12px; align-items:center;">
					<a class="button button-secondary" href="<?php echo esc_url( $rebuild_url ); ?>">
						<?php echo esc_html__( 'Rebuild Snapshot', 'lpr-backorder-allocator' ); ?>
					</a>
					<span style="opacity:.8;">
						<?php
						echo esc_html(
							sprintf(
								/* translators: %s: datetime */
								__( 'Last built: %s', 'lpr-backorder-allocator' ),
								$built_ts ? wp_date( 'Y-m-d H:i:s', $built_ts ) : __( 'never', 'lpr-backorder-allocator' )
							)
						);
						?>
					</span>
					<span style="opacity:.8;">
						<?php
						echo esc_html(
							sprintf(
								/* translators: %s: count */
								__( 'Orders in view: %s', 'lpr-backorder-allocator' ),
								number_format_i18n( count( $orders ) )
							)
						);
						?>
					</span>
				</div>

				<style>
					.lpr-bo-table { width:100%; border-collapse:collapse; }
					.lpr-bo-table th, .lpr-bo-table td { padding:8px; border-bottom:1px solid #e5e5e5; text-align:left; vertical-align:top; }
					.lpr-bo-table th.num, .lpr-bo-table td.num { text-align:right; white-space:nowrap; }
					.lpr-badge { display:inline-block; padding:2px 6px; border-radius:3px; font-size:11px; margin-left:6px; }
					.lpr-badge--bo { background:#f0ad4e; color:#111; }
					.lpr-badge--unalloc { background:#d9534f; color:#fff; }
					.lpr-items { margin:6px 0 14px 0; width:100%; border-collapse:collapse; }
					.lpr-items th, .lpr-items td { padding:6px; border-bottom:1px solid #f0f0f0; font-size:12px; }
					.lpr-muted { opacity:.75; }
				</style>

				<table class="widefat striped lpr-bo-table">
					<thead>
						<tr>
							<th><?php echo esc_html__( 'Order', 'lpr-backorder-allocator' ); ?></th>
							<th><?php echo esc_html__( 'Customer', 'lpr-backorder-allocator' ); ?></th>
							<th><?php echo esc_html__( 'Status / Created', 'lpr-backorder-allocator' ); ?></th>
							<th><?php echo esc_html__( 'Order ETA', 'lpr-backorder-allocator' ); ?></th>
							<th class="num"><?php echo esc_html__( 'Total', 'lpr-backorder-allocator' ); ?></th>
						</tr>
					</thead>
					<tbody>
					<?php if ( empty( $orders ) ) : ?>
						<tr><td colspan="5"><?php echo esc_html__( 'No orders currently blocked by backorders.', 'lpr-backorder-allocator' ); ?></td></tr>
					<?php else : ?>
						<?php foreach ( $orders as $o ) : 
							$order_edit = get_edit_post_link( (int) $o['order_id'], 'url' );
							$eta_disp   = $o['order_eta'] ? $o['order_eta'] : '—';
							$total_html = function_exists( 'wc_price' )
								? wc_price( (float) $o['total'], array( 'currency' => (string) $o['currency'] ) )
								: esc_html( (string) $o['total'] );
						?>
							<tr>
								<td>
									<?php if ( $order_edit ) : ?>
										<a href="<?php echo esc_url( $order_edit ); ?>">#<?php echo esc_html( (string) $o['order_number'] ); ?></a>
									<?php else : ?>
										#<?php echo esc_html( (string) $o['order_number'] ); ?>
									<?php endif; ?>
									<?php if ( ! empty( $o['has_unallocated'] ) ) : ?>
										<span class="lpr-badge lpr-badge--unalloc"><?php echo esc_html__( 'Unallocated items', 'lpr-backorder-allocator' ); ?></span>
									<?php endif; ?>
								</td>
								<td>
									<?php echo esc_html( (string) $o['customer_name'] ); ?>
									<?php if ( ! empty( $o['customer_email'] ) ) : ?>
										<div class="lpr-muted"><?php echo esc_html( (string) $o['customer_email'] ); ?></div>
									<?php endif; ?>
								</td>
								<td>
									<div><?php echo esc_html( (string) $o['status'] ); ?></div>
									<div class="lpr-muted"><?php echo esc_html( (string) $o['created'] ); ?></div>
								</td>
								<td><?php echo esc_html( $eta_disp ); ?></td>
								<td class="num"><?php echo wp_kses_post( $total_html ); ?></td>
							</tr>
							<tr>
								<td colspan="5" style="padding-top:0;">
									<table class="lpr-items">
										<thead>
											<tr>
												<th><?php echo esc_html__( 'Item', 'lpr-backorder-allocator' ); ?></th>
												<th class="num"><?php echo esc_html__( 'Qty', 'lpr-backorder-allocator' ); ?></th>
												<th class="num"><?php echo esc_html__( 'Backordered', 'lpr-backorder-allocator' ); ?></th>
												<th class="num"><?php echo esc_html__( 'Allocated', 'lpr-backorder-allocator' ); ?></th>
												<th class="num"><?php echo esc_html__( 'Need', 'lpr-backorder-allocator' ); ?></th>
												<th><?php echo esc_html__( 'Line ETA', 'lpr-backorder-allocator' ); ?></th>
											</tr>
										</thead>
										<tbody>
											<?php foreach ( (array) $o['items'] as $it ) : ?>
												<tr>
													<td>
														<?php echo esc_html( (string) $it['name'] ); ?>
														<?php if ( ! empty( $it['sku'] ) ) : ?>
															<span class="lpr-muted">[<?php echo esc_html( (string) $it['sku'] ); ?>]</span>
														<?php endif; ?>
														<?php if ( ! empty( $it['is_backordered'] ) ) : ?>
															<span class="lpr-badge lpr-badge--bo"><?php echo esc_html__( 'Backorder', 'lpr-backorder-allocator' ); ?></span>
														<?php endif; ?>
														<?php if ( ! empty( $it['is_unallocated'] ) ) : ?>
															<span class="lpr-badge lpr-badge--unalloc"><?php echo esc_html__( 'Unallocated', 'lpr-backorder-allocator' ); ?></span>
														<?php endif; ?>
													</td>
													<td class="num"><?php echo esc_html( (string) (int) $it['qty'] ); ?></td>
													<td class="num"><?php echo esc_html( (string) (int) $it['desired'] ); ?></td>
													<td class="num"><?php echo esc_html( (string) (int) $it['allocated'] ); ?></td>
													<td class="num"><?php echo esc_html( (string) (int) $it['need'] ); ?></td>
													<td><?php echo esc_html( $it['line_eta'] ?: '—' ); ?></td>
												</tr>
											<?php endforeach; ?>
										</tbody>
									</table>
								</td>
							</tr>
						<?php endforeach; ?>
					<?php endif; ?>
					</tbody>
				</table>
			</div>
			<?php
		}
	}
	Backorder_Orders_Page::init();
}	
														
